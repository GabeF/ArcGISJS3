<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>test\deployment\data\tmp\dojo\dijit\_editor\RichText.js - YUI ArcGIS</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="YUI ArcGIS" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Main.html">Main</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: test\deployment\data\tmp\dojo\dijit\_editor\RichText.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
define(&quot;dijit/_editor/RichText&quot;, [
	&quot;dojo/_base/array&quot;, // array.forEach array.indexOf array.some
	&quot;dojo/_base/config&quot;, // config
	&quot;dojo/_base/declare&quot;, // declare
	&quot;dojo/_base/Deferred&quot;, // Deferred
	&quot;dojo/dom&quot;, // dom.byId
	&quot;dojo/dom-attr&quot;, // domAttr.set or get
	&quot;dojo/dom-class&quot;, // domClass.add domClass.remove
	&quot;dojo/dom-construct&quot;, // domConstruct.create domConstruct.destroy domConstruct.place
	&quot;dojo/dom-geometry&quot;, // domGeometry.position
	&quot;dojo/dom-style&quot;, // domStyle.getComputedStyle domStyle.set
	&quot;dojo/_base/kernel&quot;, // kernel.deprecated, kernel.locale
	&quot;dojo/keys&quot;, // keys.BACKSPACE keys.TAB
	&quot;dojo/_base/lang&quot;, // lang.clone lang.hitch lang.isArray lang.isFunction lang.isString lang.trim
	&quot;dojo/on&quot;, // on()
	&quot;dojo/query&quot;, // query
	&quot;dojo/domReady&quot;,
	&quot;dojo/sniff&quot;, // has(&quot;ie&quot;) has(&quot;mozilla&quot;) has(&quot;opera&quot;) has(&quot;safari&quot;) has(&quot;webkit&quot;)
	&quot;dojo/string&quot;,
	&quot;dojo/topic&quot;, // topic.publish() (publish)
	&quot;dojo/_base/unload&quot;, // unload
	&quot;dojo/_base/url&quot;, // url
	&quot;dojo/window&quot;, // winUtils.get()
	&quot;../_Widget&quot;,
	&quot;../_CssStateMixin&quot;,
	&quot;../selection&quot;,
	&quot;./range&quot;,
	&quot;./html&quot;,
	&quot;../focus&quot;,
	&quot;../main&quot;    // dijit._scopeName
], function(array, config, declare, Deferred, dom, domAttr, domClass, domConstruct, domGeometry, domStyle,
			kernel, keys, lang, on, query, domReady, has, string, topic, unload, _Url, winUtils,
			_Widget, _CssStateMixin, selectionapi, rangeapi, htmlapi, focus, dijit){

	// module:
	//		dijit/_editor/RichText

	// If you want to allow for rich text saving with back/forward actions, you must add a text area to your page with
	// the id==dijit._scopeName + &quot;._editor.RichText.value&quot; (typically &quot;dijit/_editor/RichText.value). For example,
	// something like this will work:
	//
	//	&lt;textarea id=&quot;dijit._editor.RichText.value&quot; style=&quot;display:none;position:absolute;top:-100px;left:-100px;height:3px;width:3px;overflow:hidden;&quot;&gt;&lt;/textarea&gt;

	var RichText = declare(&quot;dijit._editor.RichText&quot;, [_Widget, _CssStateMixin], {
		// summary:
		//		dijit/_editor/RichText is the core of dijit.Editor, which provides basic
		//		WYSIWYG editing features.
		//
		// description:
		//		dijit/_editor/RichText is the core of dijit.Editor, which provides basic
		//		WYSIWYG editing features. It also encapsulates the differences
		//		of different js engines for various browsers.  Do not use this widget
		//		with an HTML &amp;lt;TEXTAREA&amp;gt; tag, since the browser unescapes XML escape characters,
		//		like &amp;lt;.  This can have unexpected behavior and lead to security issues
		//		such as scripting attacks.
		//
		// tags:
		//		private

		constructor: function(params /*===== , srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Initial settings for any of the widget attributes, except readonly attributes.
			// srcNodeRef: DOMNode
			//		The widget replaces the specified DOMNode.

			// contentPreFilters: Function(String)[]
			//		Pre content filter function register array.
			//		these filters will be executed before the actual
			//		editing area gets the html content.
			this.contentPreFilters = [];

			// contentPostFilters: Function(String)[]
			//		post content filter function register array.
			//		These will be used on the resulting html
			//		from contentDomPostFilters. The resulting
			//		content is the final html (returned by getValue()).
			this.contentPostFilters = [];

			// contentDomPreFilters: Function(DomNode)[]
			//		Pre content dom filter function register array.
			//		These filters are applied after the result from
			//		contentPreFilters are set to the editing area.
			this.contentDomPreFilters = [];

			// contentDomPostFilters: Function(DomNode)[]
			//		Post content dom filter function register array.
			//		These filters are executed on the editing area dom.
			//		The result from these will be passed to contentPostFilters.
			this.contentDomPostFilters = [];

			// editingAreaStyleSheets: dojo._URL[]
			//		array to store all the stylesheets applied to the editing area
			this.editingAreaStyleSheets = [];

			// Make a copy of this.events before we start writing into it, otherwise we
			// will modify the prototype which leads to bad things on pages w/multiple editors
			this.events = [].concat(this.events);

			this._keyHandlers = {};

			if(params &amp;&amp; lang.isString(params.value)){
				this.value = params.value;
			}

			this.onLoadDeferred = new Deferred();
		},

		baseClass: &quot;dijitEditor&quot;,

		// inheritWidth: Boolean
		//		whether to inherit the parent&#x27;s width or simply use 100%
		inheritWidth: false,

		// focusOnLoad: [deprecated] Boolean
		//		Focus into this widget when the page is loaded
		focusOnLoad: false,

		// name: String?
		//		Specifies the name of a (hidden) &#x60;&lt;textarea&gt;&#x60; node on the page that&#x27;s used to save
		//		the editor content on page leave.   Used to restore editor contents after navigating
		//		to a new page and then hitting the back button.
		name: &quot;&quot;,

		// styleSheets: [const] String
		//		semicolon (&quot;;&quot;) separated list of css files for the editing area
		styleSheets: &quot;&quot;,

		// height: String
		//		Set height to fix the editor at a specific height, with scrolling.
		//		By default, this is 300px.  If you want to have the editor always
		//		resizes to accommodate the content, use AlwaysShowToolbar plugin
		//		and set height=&quot;&quot;.  If this editor is used within a layout widget,
		//		set height=&quot;100%&quot;.
		height: &quot;300px&quot;,

		// minHeight: String
		//		The minimum height that the editor should have.
		minHeight: &quot;1em&quot;,

		// isClosed: [private] Boolean
		isClosed: true,

		// isLoaded: [private] Boolean
		isLoaded: false,

		// _SEPARATOR: [private] String
		//		Used to concat contents from multiple editors into a single string,
		//		so they can be saved into a single &#x60;&lt;textarea&gt;&#x60; node.  See &quot;name&quot; attribute.
		_SEPARATOR: &quot;@@**%%__RICHTEXTBOUNDRY__%%**@@&quot;,

		// _NAME_CONTENT_SEP: [private] String
		//		USed to separate name from content.  Just a colon isn&#x27;t safe.
		_NAME_CONTENT_SEP: &quot;@@**%%:%%**@@&quot;,

		// onLoadDeferred: [readonly] dojo/promise/Promise
		//		Deferred which is fired when the editor finishes loading.
		//		Call myEditor.onLoadDeferred.then(callback) it to be informed
		//		when the rich-text area initialization is finalized.
		onLoadDeferred: null,

		// isTabIndent: Boolean
		//		Make tab key and shift-tab indent and outdent rather than navigating.
		//		Caution: sing this makes web pages inaccessible to users unable to use a mouse.
		isTabIndent: false,

		// disableSpellCheck: [const] Boolean
		//		When true, disables the browser&#x27;s native spell checking, if supported.
		//		Works only in Firefox.
		disableSpellCheck: false,

		postCreate: function(){
			if(&quot;textarea&quot; === this.domNode.tagName.toLowerCase()){
				console.warn(&quot;RichText should not be used with the TEXTAREA tag.  See dijit._editor.RichText docs.&quot;);
			}

			// Push in the builtin filters now, making them the first executed, but not over-riding anything
			// users passed in.  See: #6062
			this.contentPreFilters = [
				lang.trim,	// avoid IE10 problem hitting ENTER on last line when there&#x27;s a trailing \n.
				lang.hitch(this, &quot;_preFixUrlAttributes&quot;)
			].concat(this.contentPreFilters);
			if(has(&quot;mozilla&quot;)){
				this.contentPreFilters = [this._normalizeFontStyle].concat(this.contentPreFilters);
				this.contentPostFilters = [this._removeMozBogus].concat(this.contentPostFilters);
			}
			if(has(&quot;webkit&quot;)){
				// Try to clean up WebKit bogus artifacts.  The inserted classes
				// made by WebKit sometimes messes things up.
				this.contentPreFilters = [this._removeWebkitBogus].concat(this.contentPreFilters);
				this.contentPostFilters = [this._removeWebkitBogus].concat(this.contentPostFilters);
			}
			if(has(&quot;ie&quot;) || has(&quot;trident&quot;)){
				// IE generates &lt;strong&gt; and &lt;em&gt; but we want to normalize to &lt;b&gt; and &lt;i&gt;
				// Still happens in IE11, but doesn&#x27;t happen with Edge.
				this.contentPostFilters = [this._normalizeFontStyle].concat(this.contentPostFilters);
				this.contentDomPostFilters = [lang.hitch(this, &quot;_stripBreakerNodes&quot;)].concat(this.contentDomPostFilters);
			}
			this.contentDomPostFilters = [lang.hitch(this, &quot;_stripTrailingEmptyNodes&quot;)].concat(this.contentDomPostFilters);
			this.inherited(arguments);

			topic.publish(dijit._scopeName + &quot;._editor.RichText::init&quot;, this);
		},

		startup: function(){
			this.inherited(arguments);

			// Don&#x27;t call open() until startup() because we need to be attached to the DOM, and also if we are the
			// child of a StackContainer, let StackContainer._setupChild() do DOM manipulations before iframe is
			// created, to avoid duplicate onload call.
			this.open();
			this.setupDefaultShortcuts();
		},

		setupDefaultShortcuts: function(){
			// summary:
			//		Add some default key handlers
			// description:
			//		Overwrite this to setup your own handlers. The default
			//		implementation does not use Editor commands, but directly
			//		executes the builtin commands within the underlying browser
			//		support.
			// tags:
			//		protected
			var exec = lang.hitch(this, function(cmd, arg){
				return function(){
					return !this.execCommand(cmd, arg);
				};
			});

			var ctrlKeyHandlers = {
				b: exec(&quot;bold&quot;),
				i: exec(&quot;italic&quot;),
				u: exec(&quot;underline&quot;),
				a: exec(&quot;selectall&quot;),
				s: function(){
					this.save(true);
				},
				m: function(){
					this.isTabIndent = !this.isTabIndent;
				},

				&quot;1&quot;: exec(&quot;formatblock&quot;, &quot;h1&quot;),
				&quot;2&quot;: exec(&quot;formatblock&quot;, &quot;h2&quot;),
				&quot;3&quot;: exec(&quot;formatblock&quot;, &quot;h3&quot;),
				&quot;4&quot;: exec(&quot;formatblock&quot;, &quot;h4&quot;),

				&quot;\\&quot;: exec(&quot;insertunorderedlist&quot;)
			};

			if(!has(&quot;ie&quot;)){
				ctrlKeyHandlers.Z = exec(&quot;redo&quot;); //FIXME: undo?
			}

			var key;
			for(key in ctrlKeyHandlers){
				this.addKeyHandler(key, true, false, ctrlKeyHandlers[key]);
			}
		},

		// events: [private] String[]
		//		 events which should be connected to the underlying editing area
		events: [&quot;onKeyDown&quot;, &quot;onKeyUp&quot;], // onClick handled specially

		// captureEvents: [deprecated] String[]
		//		 Events which should be connected to the underlying editing
		//		 area, events in this array will be addListener with
		//		 capture=true.
		// TODO: looking at the code I don&#x27;t see any distinction between events and captureEvents,
		// so get rid of this for 2.0 if not sooner
		captureEvents: [],

		_editorCommandsLocalized: false,
		_localizeEditorCommands: function(){
			// summary:
			//		When IE is running in a non-English locale, the API actually changes,
			//		so that we have to say (for example) danraku instead of p (for paragraph).
			//		Handle that here.
			// tags:
			//		private
			if(RichText._editorCommandsLocalized){
				// Use the already generate cache of mappings.
				this._local2NativeFormatNames = RichText._local2NativeFormatNames;
				this._native2LocalFormatNames = RichText._native2LocalFormatNames;
				return;
			}
			RichText._editorCommandsLocalized = true;
			RichText._local2NativeFormatNames = {};
			RichText._native2LocalFormatNames = {};
			this._local2NativeFormatNames = RichText._local2NativeFormatNames;
			this._native2LocalFormatNames = RichText._native2LocalFormatNames;
			//in IE, names for blockformat is locale dependent, so we cache the values here

			//put p after div, so if IE returns Normal, we show it as paragraph
			//We can distinguish p and div if IE returns Normal, however, in order to detect that,
			//we have to call this.document.selection.createRange().parentElement() or such, which
			//could slow things down. Leave it as it is for now
			var formats = [&#x27;div&#x27;, &#x27;p&#x27;, &#x27;pre&#x27;, &#x27;h1&#x27;, &#x27;h2&#x27;, &#x27;h3&#x27;, &#x27;h4&#x27;, &#x27;h5&#x27;, &#x27;h6&#x27;, &#x27;ol&#x27;, &#x27;ul&#x27;, &#x27;address&#x27;];
			var localhtml = &quot;&quot;, format, i = 0;
			while((format = formats[i++])){
				//append a &lt;br&gt; after each element to separate the elements more reliably
				if(format.charAt(1) !== &#x27;l&#x27;){
					localhtml += &quot;&lt;&quot; + format + &quot;&gt;&lt;span&gt;content&lt;/span&gt;&lt;/&quot; + format + &quot;&gt;&lt;br/&gt;&quot;;
				}else{
					localhtml += &quot;&lt;&quot; + format + &quot;&gt;&lt;li&gt;content&lt;/li&gt;&lt;/&quot; + format + &quot;&gt;&lt;br/&gt;&quot;;
				}
			}
			// queryCommandValue returns empty if we hide editNode, so move it out of screen temporary
			// Also, IE9 does weird stuff unless we do it inside the editor iframe.
			var style = { position: &quot;absolute&quot;, top: &quot;0px&quot;, zIndex: 10, opacity: 0.01 };
			var div = domConstruct.create(&#x27;div&#x27;, {style: style, innerHTML: localhtml});
			this.ownerDocumentBody.appendChild(div);

			// IE9 has a timing issue with doing this right after setting
			// the inner HTML, so put a delay in.
			var inject = lang.hitch(this, function(){
				var node = div.firstChild;
				while(node){
					try{
						this.selection.selectElement(node.firstChild);
						var nativename = node.tagName.toLowerCase();
						this._local2NativeFormatNames[nativename] = document.queryCommandValue(&quot;formatblock&quot;);
						this._native2LocalFormatNames[this._local2NativeFormatNames[nativename]] = nativename;
						node = node.nextSibling.nextSibling;
						//console.log(&quot;Mapped: &quot;, nativename, &quot; to: &quot;, this._local2NativeFormatNames[nativename]);
					}catch(e){ /*Sqelch the occasional IE9 error */
					}
				}
				domConstruct.destroy(div);
			});
			this.defer(inject);
		},

		open: function(/*DomNode?*/ element){
			// summary:
			//		Transforms the node referenced in this.domNode into a rich text editing
			//		node.
			// description:
			//		Sets up the editing area asynchronously. This will result in
			//		the creation and replacement with an iframe.
			// tags:
			//		private

			if(!this.onLoadDeferred || this.onLoadDeferred.fired &gt;= 0){
				this.onLoadDeferred = new Deferred();
			}

			if(!this.isClosed){
				this.close();
			}
			topic.publish(dijit._scopeName + &quot;._editor.RichText::open&quot;, this);

			if(arguments.length === 1 &amp;&amp; element.nodeName){ // else unchanged
				this.domNode = element;
			}

			var dn = this.domNode;

			// Compute initial value of the editor
			var html;
			if(lang.isString(this.value)){
				// Allow setting the editor content programmatically instead of
				// relying on the initial content being contained within the target
				// domNode.
				html = this.value;
				dn.innerHTML = &quot;&quot;;
			}else if(dn.nodeName &amp;&amp; dn.nodeName.toLowerCase() == &quot;textarea&quot;){
				// if we were created from a textarea, then we need to create a
				// new editing harness node.
				var ta = (this.textarea = dn);
				this.name = ta.name;
				html = ta.value;
				dn = this.domNode = this.ownerDocument.createElement(&quot;div&quot;);
				dn.setAttribute(&#x27;widgetId&#x27;, this.id);
				ta.removeAttribute(&#x27;widgetId&#x27;);
				dn.cssText = ta.cssText;
				dn.className += &quot; &quot; + ta.className;
				domConstruct.place(dn, ta, &quot;before&quot;);
				var tmpFunc = lang.hitch(this, function(){
					//some browsers refuse to submit display=none textarea, so
					//move the textarea off screen instead
					domStyle.set(ta, {
						display: &quot;block&quot;,
						position: &quot;absolute&quot;,
						top: &quot;-1000px&quot;
					});

					if(has(&quot;ie&quot;)){ //nasty IE bug: abnormal formatting if overflow is not hidden
						var s = ta.style;
						this.__overflow = s.overflow;
						s.overflow = &quot;hidden&quot;;
					}
				});
				if(has(&quot;ie&quot;)){
					this.defer(tmpFunc, 10);
				}else{
					tmpFunc();
				}

				if(ta.form){
					var resetValue = ta.value;
					this.reset = function(){
						var current = this.getValue();
						if(current !== resetValue){
							this.replaceValue(resetValue);
						}
					};
					on(ta.form, &quot;submit&quot;, lang.hitch(this, function(){
						// Copy value to the &lt;textarea&gt; so it gets submitted along with form.
						// FIXME: should we be calling close() here instead?
						domAttr.set(ta, &#x27;disabled&#x27;, this.disabled); // don&#x27;t submit the value if disabled
						ta.value = this.getValue();
					}));
				}
			}else{
				html = htmlapi.getChildrenHtml(dn);
				dn.innerHTML = &quot;&quot;;
			}
			this.value = html;

			// If we&#x27;re a list item we have to put in a blank line to force the
			// bullet to nicely align at the top of text
			if(dn.nodeName &amp;&amp; dn.nodeName === &quot;LI&quot;){
				dn.innerHTML = &quot; &lt;br&gt;&quot;;
			}

			// Construct the editor div structure.
			this.header = dn.ownerDocument.createElement(&quot;div&quot;);
			dn.appendChild(this.header);
			this.editingArea = dn.ownerDocument.createElement(&quot;div&quot;);
			dn.appendChild(this.editingArea);
			this.footer = dn.ownerDocument.createElement(&quot;div&quot;);
			dn.appendChild(this.footer);

			if(!this.name){
				this.name = this.id + &quot;_AUTOGEN&quot;;
			}

			// User has pressed back/forward button so we lost the text in the editor, but it&#x27;s saved
			// in a hidden &lt;textarea&gt; (which contains the data for all the editors on this page),
			// so get editor value from there
			if(this.name !== &quot;&quot; &amp;&amp; (!config[&quot;useXDomain&quot;] || config[&quot;allowXdRichTextSave&quot;])){
				var saveTextarea = dom.byId(dijit._scopeName + &quot;._editor.RichText.value&quot;);
				if(saveTextarea &amp;&amp; saveTextarea.value !== &quot;&quot;){
					var datas = saveTextarea.value.split(this._SEPARATOR), i = 0, dat;
					while((dat = datas[i++])){
						var data = dat.split(this._NAME_CONTENT_SEP);
						if(data[0] === this.name){
							this.value = data[1];
							datas = datas.splice(i, 1);
							saveTextarea.value = datas.join(this._SEPARATOR);
							break;
						}
					}
				}

				if(!RichText._globalSaveHandler){
					RichText._globalSaveHandler = {};
					unload.addOnUnload(function(){
						var id;
						for(id in RichText._globalSaveHandler){
							var f = RichText._globalSaveHandler[id];
							if(lang.isFunction(f)){
								f();
							}
						}
					});
				}
				RichText._globalSaveHandler[this.id] = lang.hitch(this, &quot;_saveContent&quot;);
			}

			this.isClosed = false;

			var ifr = (this.editorObject = this.iframe = this.ownerDocument.createElement(&#x27;iframe&#x27;));
			ifr.id = this.id + &quot;_iframe&quot;;
			ifr.style.border = &quot;none&quot;;
			ifr.style.width = &quot;100%&quot;;
			if(this._layoutMode){
				// iframe should be 100% height, thus getting it&#x27;s height from surrounding
				// &lt;div&gt; (which has the correct height set by Editor)
				ifr.style.height = &quot;100%&quot;;
			}else{
				if(has(&quot;ie&quot;) &gt;= 7){
					if(this.height){
						ifr.style.height = this.height;
					}
					if(this.minHeight){
						ifr.style.minHeight = this.minHeight;
					}
				}else{
					ifr.style.height = this.height ? this.height : this.minHeight;
				}
			}
			ifr.frameBorder = 0;
			ifr._loadFunc = lang.hitch(this, function(w){
				// This method is called when the editor is first loaded and also if the Editor&#x27;s
				// dom node is repositioned. Unfortunately repositioning the Editor tends to
				// clear the iframe&#x27;s contents, so we can&#x27;t just no-op in that case.

				this.window = w;
				this.document = w.document;

				// instantiate class to access selected text in editor&#x27;s iframe
				this.selection = new selectionapi.SelectionManager(w);

				if(has(&quot;ie&quot;)){
					this._localizeEditorCommands();
				}

				// Do final setup and set contents of editor.
				// Use get(&quot;value&quot;) rather than html in case _loadFunc() is being called for a second time
				// because editor&#x27;s DOMNode was repositioned.
				this.onLoad(this.get(&quot;value&quot;));
			});

			// Attach iframe to document, and set the initial (blank) content.
			var src = this._getIframeDocTxt().replace(/\\/g, &quot;\\\\&quot;).replace(/&#x27;/g, &quot;\\&#x27;&quot;),
				s;

			// IE10 and earlier will throw an &quot;Access is denied&quot; error when attempting to access the parent frame if
			// document.domain has been set, unless the child frame also has the same document.domain set. In some
			// cases, we can only set document.domain while the document is being constructed using open/write/close;
			// attempting to set it later results in a different &quot;This method can&#x27;t be used in this context&quot; error.
			// However, in at least IE9-10, sometimes the parent.window check will succeed and the access failure will
			// only happen later when trying to access frameElement, so there is an additional check and fix there
			// as well. See #17529
			if (has(&quot;ie&quot;) &lt; 11) {
				s = &#x27;javascript:document.open();try{parent.window;}catch(e){document.domain=&quot;&#x27; + document.domain + &#x27;&quot;;}&#x27; +
					&#x27;document.write(\&#x27;&#x27; + src + &#x27;\&#x27;);document.close()&#x27;;
			}
			else {
				s = &quot;javascript: &#x27;&quot; + src + &quot;&#x27;&quot;;
			}

			// Attach to document before setting the content, to avoid problem w/iframe running in
			// wrong security context (IE9 and IE11), see #16633.
			this.editingArea.appendChild(ifr);
			ifr.src = s;

			// TODO: this is a guess at the default line-height, kinda works
			if(dn.nodeName === &quot;LI&quot;){
				dn.lastChild.style.marginTop = &quot;-1.2em&quot;;
			}

			domClass.add(this.domNode, this.baseClass);
		},

		//static cache variables shared among all instance of this class
		_local2NativeFormatNames: {},
		_native2LocalFormatNames: {},

		_getIframeDocTxt: function(){
			// summary:
			//		Generates the boilerplate text of the document inside the iframe (ie, &#x60;&lt;html&gt;&lt;head&gt;...&lt;/head&gt;&lt;body/&gt;&lt;/html&gt;&#x60;).
			//		Editor content (if not blank) should be added afterwards.
			// tags:
			//		private
			var _cs = domStyle.getComputedStyle(this.domNode);

			// Find any associated label element, aria-label, or aria-labelledby and get unescaped text.
			var title;
			if(this[&quot;aria-label&quot;]){
				title = this[&quot;aria-label&quot;];
			}else{
				var labelNode = query(&#x27;label[for=&quot;&#x27; + this.id + &#x27;&quot;]&#x27;, this.ownerDocument)[0] ||
						dom.byId(this[&quot;aria-labelledby&quot;], this.ownerDocument);
				if(labelNode){
					title = labelNode.textContent || labelNode.innerHTML || &quot;&quot;;
				}
			}

			// The contents inside of &lt;body&gt;.  The real contents are set later via a call to setValue().
			// In auto-expand mode, need a wrapper div for AlwaysShowToolbar plugin to correctly
			// expand/contract the editor as the content changes.
			var html = &quot;&lt;div id=&#x27;dijitEditorBody&#x27; role=&#x27;textbox&#x27; aria-multiline=&#x27;true&#x27; &quot; +
					(title ? &quot; aria-label=&#x27;&quot; + string.escape(title) + &quot;&#x27;&quot; : &quot;&quot;) + &quot;&gt;&lt;/div&gt;&quot;;

			var font = [ _cs.fontWeight, _cs.fontSize, _cs.fontFamily ].join(&quot; &quot;);

			// line height is tricky - applying a units value will mess things up.
			// if we can&#x27;t get a non-units value, bail out.
			var lineHeight = _cs.lineHeight;
			if(lineHeight.indexOf(&quot;px&quot;) &gt;= 0){
				lineHeight = parseFloat(lineHeight) / parseFloat(_cs.fontSize);
				// console.debug(lineHeight);
			}else if(lineHeight.indexOf(&quot;em&quot;) &gt;= 0){
				lineHeight = parseFloat(lineHeight);
			}else{
				// If we can&#x27;t get a non-units value, just default
				// it to the CSS spec default of &#x27;normal&#x27;.  Seems to
				// work better, esp on IE, than &#x27;1.0&#x27;
				lineHeight = &quot;normal&quot;;
			}
			var userStyle = &quot;&quot;;
			var self = this;
			this.style.replace(/(^|;)\s*(line-|font-?)[^;]+/ig, function(match){
				match = match.replace(/^;/ig, &quot;&quot;) + &#x27;;&#x27;;
				var s = match.split(&quot;:&quot;)[0];
				if(s){
					s = lang.trim(s);
					s = s.toLowerCase();
					var i;
					var sC = &quot;&quot;;
					for(i = 0; i &lt; s.length; i++){
						var c = s.charAt(i);
						switch(c){
							case &quot;-&quot;:
								i++;
								c = s.charAt(i).toUpperCase();
							default:
								sC += c;
						}
					}
					domStyle.set(self.domNode, sC, &quot;&quot;);
				}
				userStyle += match + &#x27;;&#x27;;
			});

			// Now that we have the title, also set it as the title attribute on the iframe
			this.iframe.setAttribute(&quot;title&quot;, title);

			// if this.lang is unset then use default value, to avoid invalid setting of lang=&quot;&quot;
			var language = this.lang || kernel.locale.replace(/-.*/, &quot;&quot;);

			return [
				&quot;&lt;!DOCTYPE html&gt;&quot;,
				&quot;&lt;html lang=&#x27;&quot; + language + &quot;&#x27;&quot; + (this.isLeftToRight() ? &quot;&quot; : &quot; dir=&#x27;rtl&#x27;&quot;) + &quot;&gt;\n&quot;,
				&quot;&lt;head&gt;\n&quot;,
				&quot;&lt;meta http-equiv=&#x27;Content-Type&#x27; content=&#x27;text/html&#x27;&gt;\n&quot;,
				title ? &quot;&lt;title&gt;&quot; + string.escape(title) + &quot;&lt;/title&gt;&quot; : &quot;&quot;,
				&quot;&lt;style&gt;\n&quot;,
				&quot;\tbody,html {\n&quot;,
				&quot;\t\tbackground:transparent;\n&quot;,
				&quot;\t\tpadding: 1px 0 0 0;\n&quot;,
				&quot;\t\tmargin: -1px 0 0 0;\n&quot;, // remove extraneous vertical scrollbar on safari and firefox
				&quot;\t}\n&quot;,
				&quot;\tbody,html,#dijitEditorBody { outline: none; }&quot;,

				// Set &lt;body&gt; to expand to full size of editor, so clicking anywhere will work.
				// Except in auto-expand mode, in which case the editor expands to the size of &lt;body&gt;.
				// Also determine how scrollers should be applied.  In autoexpand mode (height = &quot;&quot;) no scrollers on y at all.
				// But in fixed height mode we want both x/y scrollers.
				// Scrollers go on &lt;body&gt; since it&#x27;s been set to height: 100%.
				&quot;html { height: 100%; width: 100%; overflow: hidden; }\n&quot;,	// scroll bar is on #dijitEditorBody, shouldn&#x27;t be on &lt;html&gt;
				this.height ? &quot;\tbody,#dijitEditorBody { height: 100%; width: 100%; overflow: auto; }\n&quot; :
					&quot;\tbody,#dijitEditorBody { min-height: &quot; + this.minHeight + &quot;; width: 100%; overflow-x: auto; overflow-y: hidden; }\n&quot;,

				// TODO: left positioning will cause contents to disappear out of view
				//	   if it gets too wide for the visible area
				&quot;\tbody{\n&quot;,
				&quot;\t\ttop:0px;\n&quot;,
				&quot;\t\tleft:0px;\n&quot;,
				&quot;\t\tright:0px;\n&quot;,
				&quot;\t\tfont:&quot;, font, &quot;;\n&quot;,
				((this.height || has(&quot;opera&quot;)) ? &quot;&quot; : &quot;\t\tposition: fixed;\n&quot;),
				&quot;\t\tline-height:&quot;, lineHeight, &quot;;\n&quot;,
				&quot;\t}\n&quot;,
				&quot;\tp{ margin: 1em 0; }\n&quot;,

				&quot;\tli &gt; ul:-moz-first-node, li &gt; ol:-moz-first-node{ padding-top: 1.2em; }\n&quot;,
				// Can&#x27;t set min-height in IE&gt;=9, it puts layout on li, which puts move/resize handles.
				// Also can&#x27;t set it on Edge, as it leads to strange behavior where hitting the return key
				// doesn&#x27;t start a new list item.
				(has(&quot;ie&quot;) || has(&quot;trident&quot;) || has(&quot;edge&quot;) ? &quot;&quot; : &quot;\tli{ min-height:1.2em; }\n&quot;),
				&quot;&lt;/style&gt;\n&quot;,
				this._applyEditingAreaStyleSheets(), &quot;\n&quot;,
				&quot;&lt;/head&gt;\n&lt;body role=&#x27;application&#x27;&quot;,
				title ? &quot; aria-label=&#x27;&quot; + string.escape(title) + &quot;&#x27;&quot; : &quot;&quot;,

				// Onload handler fills in real editor content.
				// On IE9, sometimes onload is called twice, and the first time frameElement is null (test_FullScreen.html)
				// On IE9-10, it is also possible that accessing window.parent in the initial creation of the
				// iframe DOM will succeed, but trying to access window.frameElement will fail, in which case we
				// *can* set the domain without a &quot;This method can&#x27;t be used in this context&quot; error. See #17529
				&quot;onload=&#x27;try{frameElement &amp;&amp; frameElement._loadFunc(window,document)}catch(e){document.domain=\&quot;&quot; + document.domain + &quot;\&quot;;frameElement._loadFunc(window,document)}&#x27; &quot;,
				&quot;style=&#x27;&quot; + userStyle + &quot;&#x27;&gt;&quot;, html, &quot;&lt;/body&gt;\n&lt;/html&gt;&quot;
			].join(&quot;&quot;); // String
		},

		_applyEditingAreaStyleSheets: function(){
			// summary:
			//		apply the specified css files in styleSheets
			// tags:
			//		private
			var files = [];
			if(this.styleSheets){
				files = this.styleSheets.split(&#x27;;&#x27;);
				this.styleSheets = &#x27;&#x27;;
			}

			//empty this.editingAreaStyleSheets here, as it will be filled in addStyleSheet
			files = files.concat(this.editingAreaStyleSheets);
			this.editingAreaStyleSheets = [];

			var text = &#x27;&#x27;, i = 0, url, ownerWindow = winUtils.get(this.ownerDocument);
			while((url = files[i++])){
				var abstring = (new _Url(ownerWindow.location, url)).toString();
				this.editingAreaStyleSheets.push(abstring);
				text += &#x27;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&#x27; + abstring + &#x27;&quot;/&gt;&#x27;;
			}
			return text;
		},

		addStyleSheet: function(/*dojo/_base/url*/ uri){
			// summary:
			//		add an external stylesheet for the editing area
			// uri:
			//		Url of the external css file
			var url = uri.toString(), ownerWindow = winUtils.get(this.ownerDocument);

			//if uri is relative, then convert it to absolute so that it can be resolved correctly in iframe
			if(url.charAt(0) === &#x27;.&#x27; || (url.charAt(0) !== &#x27;/&#x27; &amp;&amp; !uri.host)){
				url = (new _Url(ownerWindow.location, url)).toString();
			}

			if(array.indexOf(this.editingAreaStyleSheets, url) &gt; -1){
//			console.debug(&quot;dijit/_editor/RichText.addStyleSheet(): Style sheet &quot;+url+&quot; is already applied&quot;);
				return;
			}

			this.editingAreaStyleSheets.push(url);
			this.onLoadDeferred.then(lang.hitch(this, function(){
				if(this.document.createStyleSheet){ //IE
					this.document.createStyleSheet(url);
				}else{ //other browser
					var head = this.document.getElementsByTagName(&quot;head&quot;)[0];
					var stylesheet = this.document.createElement(&quot;link&quot;);
					stylesheet.rel = &quot;stylesheet&quot;;
					stylesheet.type = &quot;text/css&quot;;
					stylesheet.href = url;
					head.appendChild(stylesheet);
				}
			}));
		},

		removeStyleSheet: function(/*dojo/_base/url*/ uri){
			// summary:
			//		remove an external stylesheet for the editing area
			var url = uri.toString(), ownerWindow = winUtils.get(this.ownerDocument);
			//if uri is relative, then convert it to absolute so that it can be resolved correctly in iframe
			if(url.charAt(0) === &#x27;.&#x27; || (url.charAt(0) !== &#x27;/&#x27; &amp;&amp; !uri.host)){
				url = (new _Url(ownerWindow.location, url)).toString();
			}
			var index = array.indexOf(this.editingAreaStyleSheets, url);
			if(index === -1){
//			console.debug(&quot;dijit/_editor/RichText.removeStyleSheet(): Style sheet &quot;+url+&quot; has not been applied&quot;);
				return;
			}
			delete this.editingAreaStyleSheets[index];
			query(&#x27;link[href=&quot;&#x27; + url + &#x27;&quot;]&#x27;, this.window.document).orphan();
		},

		// disabled: Boolean
		//		The editor is disabled; the text cannot be changed.
		disabled: false,

		_mozSettingProps: {&#x27;styleWithCSS&#x27;: false},
		_setDisabledAttr: function(/*Boolean*/ value){
			value = !!value;
			this._set(&quot;disabled&quot;, value);
			if(!this.isLoaded){
				return;
			} // this method requires init to be complete
			var preventIEfocus = has(&quot;ie&quot;) &amp;&amp; (this.isLoaded || !this.focusOnLoad);
			if(preventIEfocus){
				this.editNode.unselectable = &quot;on&quot;;
			}
			this.editNode.contentEditable = !value;
			this.editNode.tabIndex = value ? &quot;-1&quot; : this.tabIndex;
			if(preventIEfocus){
				this.defer(function(){
					if(this.editNode){        // guard in case widget destroyed before timeout
						this.editNode.unselectable = &quot;off&quot;;
					}
				});
			}
			if(has(&quot;mozilla&quot;) &amp;&amp; !value &amp;&amp; this._mozSettingProps){
				var ps = this._mozSettingProps;
				var n;
				for(n in ps){
					if(ps.hasOwnProperty(n)){
						try{
							this.document.execCommand(n, false, ps[n]);
						}catch(e2){
						}
					}
				}
			}
			this._disabledOK = true;
		},

		/* Event handlers
		 *****************/

		onLoad: function(/*String*/ html){
			// summary:
			//		Handler after the iframe finishes loading.
			// html: String
			//		Editor contents should be set to this value
			// tags:
			//		protected

			if(!this.window.__registeredWindow){
				this.window.__registeredWindow = true;
				this._iframeRegHandle = focus.registerIframe(this.iframe);
			}

			// there&#x27;s a wrapper div around the content, see _getIframeDocTxt().
			this.editNode = this.document.body.firstChild;
			var _this = this;

			// Helper code so IE and FF skip over focusing on the &lt;iframe&gt; and just focus on the inner &lt;div&gt;.
			// See #4996 IE wants to focus the BODY tag.
			this.beforeIframeNode = domConstruct.place(&quot;&lt;div tabIndex=-1&gt;&lt;/div&gt;&quot;, this.iframe, &quot;before&quot;);
			this.afterIframeNode = domConstruct.place(&quot;&lt;div tabIndex=-1&gt;&lt;/div&gt;&quot;, this.iframe, &quot;after&quot;);
			this.iframe.onfocus = this.document.onfocus = function(){
				_this.editNode.focus();
			};

			this.focusNode = this.editNode; // for InlineEditBox


			var events = this.events.concat(this.captureEvents);
			var ap = this.iframe ? this.document : this.editNode;
			this.own.apply(this,
				array.map(events, function(item){
					var type = item.toLowerCase().replace(/^on/, &quot;&quot;);
					return on(ap, type, lang.hitch(this, item));
				}, this)
			);

			this.own(
				// mouseup in the margin does not generate an onclick event
				on(ap, &quot;mouseup&quot;, lang.hitch(this, &quot;onClick&quot;))
			);

			if(has(&quot;ie&quot;)){ // IE contentEditable
				this.own(on(this.document, &quot;mousedown&quot;, lang.hitch(this, &quot;_onIEMouseDown&quot;))); // #4996 fix focus

				// give the node Layout on IE
				// TODO: this may no longer be needed, since we&#x27;ve reverted IE to using an iframe,
				// not contentEditable.   Removing it would also probably remove the need for creating
				// the extra &lt;div&gt; in _getIframeDocTxt()
				this.editNode.style.zoom = 1.0;
			}

			if(has(&quot;webkit&quot;)){
				//WebKit sometimes doesn&#x27;t fire right on selections, so the toolbar
				//doesn&#x27;t update right.  Therefore, help it out a bit with an additional
				//listener.  A mouse up will typically indicate a display change, so fire this
				//and get the toolbar to adapt.  Reference: #9532
				this._webkitListener = this.own(on(this.document, &quot;mouseup&quot;, lang.hitch(this, &quot;onDisplayChanged&quot;)))[0];
				this.own(on(this.document, &quot;mousedown&quot;, lang.hitch(this, function(e){
					var t = e.target;
					if(t &amp;&amp; (t === this.document.body || t === this.document)){
						// Since WebKit uses the inner DIV, we need to check and set position.
						// See: #12024 as to why the change was made.
						this.defer(&quot;placeCursorAtEnd&quot;);
					}
				})));
			}

			if(has(&quot;ie&quot;)){
				// Try to make sure &#x27;hidden&#x27; elements aren&#x27;t visible in edit mode (like browsers other than IE
				// do).  See #9103
				try{
					this.document.execCommand(&#x27;RespectVisibilityInDesign&#x27;, true, null);
				}catch(e){/* squelch */
				}
			}

			this.isLoaded = true;

			this.set(&#x27;disabled&#x27;, this.disabled); // initialize content to editable (or not)

			// Note that setValue() call will only work after isLoaded is set to true (above)

			// Set up a function to allow delaying the setValue until a callback is fired
			// This ensures extensions like dijit.Editor have a way to hold the value set
			// until plugins load (and do things like register filters).
			var setContent = lang.hitch(this, function(){
				this.setValue(html);

				// Tell app that the Editor has finished loading.  isFulfilled() check avoids spurious
				// console warning when this function is called repeatedly because Editor DOMNode was moved.
				if(this.onLoadDeferred &amp;&amp; !this.onLoadDeferred.isFulfilled()){
					this.onLoadDeferred.resolve(true);
				}

				this.onDisplayChanged();
				if(this.focusOnLoad){
					// after the document loads, then set focus after updateInterval expires so that
					// onNormalizedDisplayChanged has run to avoid input caret issues
					domReady(lang.hitch(this, &quot;defer&quot;, &quot;focus&quot;, this.updateInterval));
				}
				// Save off the initial content now
				this.value = this.getValue(true);
			});
			if(this.setValueDeferred){
				this.setValueDeferred.then(setContent);
			}else{
				setContent();
			}
		},

		onKeyDown: function(/* Event */ e){
			// summary:
			//		Handler for keydown event
			// tags:
			//		protected

			// Modifier keys should not cause the onKeyPressed event because they do not cause any change to the
			// display
			if(e.keyCode === keys.SHIFT ||
			   e.keyCode === keys.ALT ||
			   e.keyCode === keys.META ||
			   e.keyCode === keys.CTRL){
				return true;
			}

			if(e.keyCode === keys.TAB &amp;&amp; this.isTabIndent){
				//prevent tab from moving focus out of editor
				e.stopPropagation();
				e.preventDefault();

				// FIXME: this is a poor-man&#x27;s indent/outdent. It would be
				// better if it added 4 &quot;&amp;nbsp;&quot; chars in an undoable way.
				// Unfortunately pasteHTML does not prove to be undoable
				if(this.queryCommandEnabled((e.shiftKey ? &quot;outdent&quot; : &quot;indent&quot;))){
					this.execCommand((e.shiftKey ? &quot;outdent&quot; : &quot;indent&quot;));
				}
			}

			// Make tab and shift-tab skip over the &lt;iframe&gt;, going from the nested &lt;div&gt; to the toolbar
			// or next element after the editor
			if(e.keyCode == keys.TAB &amp;&amp; !this.isTabIndent &amp;&amp; !e.ctrlKey &amp;&amp; !e.altKey){
				if(e.shiftKey){
					// focus the &lt;iframe&gt; so the browser will shift-tab away from it instead
					this.beforeIframeNode.focus();
				}else{
					// focus node after the &lt;iframe&gt; so the browser will tab away from it instead
					this.afterIframeNode.focus();
				}

				// Prevent onKeyPressed from firing in order to avoid triggering a display change event when the
				// editor is tabbed away; this fixes toolbar controls being inappropriately disabled in IE9+
				return true;
			}

			if(has(&quot;ie&quot;) &lt; 9 &amp;&amp; e.keyCode === keys.BACKSPACE &amp;&amp; this.document.selection.type === &quot;Control&quot;){
				// IE has a bug where if a non-text object is selected in the editor,
				// hitting backspace would act as if the browser&#x27;s back button was
				// clicked instead of deleting the object. see #1069
				e.stopPropagation();
				e.preventDefault();
				this.execCommand(&quot;delete&quot;);
			}

			if(has(&quot;ff&quot;)){
				if(e.keyCode === keys.PAGE_UP || e.keyCode === keys.PAGE_DOWN){
					if(this.editNode.clientHeight &gt;= this.editNode.scrollHeight){
						// Stop the event to prevent firefox from trapping the cursor when there is no scroll bar.
						e.preventDefault();
					}
				}
			}

			var handlers = this._keyHandlers[e.keyCode],
				args = arguments;

			if(handlers &amp;&amp; !e.altKey){
				array.some(handlers, function(h){
					// treat meta- same as ctrl-, for benefit of mac users
					if(!(h.shift ^ e.shiftKey) &amp;&amp; !(h.ctrl ^ (e.ctrlKey || e.metaKey))){
						if(!h.handler.apply(this, args)){
							e.preventDefault();
						}
						return true;
					}
				}, this);
			}

			// function call after the character has been inserted
			this.defer(&quot;onKeyPressed&quot;, 1);

			return true;
		},

		onKeyUp: function(/*===== e =====*/){
			// summary:
			//		Handler for onkeyup event
			// tags:
			//		callback
		},

		setDisabled: function(/*Boolean*/ disabled){
			// summary:
			//		Deprecated, use set(&#x27;disabled&#x27;, ...) instead.
			// tags:
			//		deprecated
			kernel.deprecated(&#x27;dijit.Editor::setDisabled is deprecated&#x27;, &#x27;use dijit.Editor::attr(&quot;disabled&quot;,boolean) instead&#x27;, 2.0);
			this.set(&#x27;disabled&#x27;, disabled);
		},
		_setValueAttr: function(/*String*/ value){
			// summary:
			//		Registers that attr(&quot;value&quot;, foo) should call setValue(foo)
			this.setValue(value);
		},
		_setDisableSpellCheckAttr: function(/*Boolean*/ disabled){
			if(this.document){
				domAttr.set(this.document.body, &quot;spellcheck&quot;, !disabled);
			}else{
				// try again after the editor is finished loading
				this.onLoadDeferred.then(lang.hitch(this, function(){
					domAttr.set(this.document.body, &quot;spellcheck&quot;, !disabled);
				}));
			}
			this._set(&quot;disableSpellCheck&quot;, disabled);
		},

		addKeyHandler: function(/*String|Number*/ key, /*Boolean*/ ctrl, /*Boolean*/ shift, /*Function*/ handler){
			// summary:
			//		Add a handler for a keyboard shortcut
			// tags:
			//		protected

			if(typeof key == &quot;string&quot;){
				// Something like Ctrl-B.  Since using keydown event, we need to convert string to a number.
				key = key.toUpperCase().charCodeAt(0);
			}

			if(!lang.isArray(this._keyHandlers[key])){
				this._keyHandlers[key] = [];
			}

			this._keyHandlers[key].push({
				shift: shift || false,
				ctrl: ctrl || false,
				handler: handler
			});
		},

		onKeyPressed: function(){
			// summary:
			//		Handler for after the user has pressed a key, and the display has been updated.
			//		(Runs on a timer so that it runs after the display is updated)
			// tags:
			//		private
			this.onDisplayChanged(/*e*/); // can&#x27;t pass in e
		},

		onClick: function(/*Event*/ e){
			// summary:
			//		Handler for when the user clicks.
			// tags:
			//		private

			// console.info(&#x27;onClick&#x27;,this._tryDesignModeOn);
			this.onDisplayChanged(e);
		},

		_onIEMouseDown: function(){
			// summary:
			//		IE only to prevent 2 clicks to focus
			// tags:
			//		protected

			if(!this.focused &amp;&amp; !this.disabled){
				this.focus();
			}
		},

		_onBlur: function(e){
			// summary:
			//		Called from focus manager when focus has moved away from this editor
			// tags:
			//		protected

			// Workaround IE problem when you blur the browser windows while an editor is focused: IE hangs
			// when you focus editor #1, blur the browser window, and then click editor #0.  See #16939.
			// Note: Edge doesn&#x27;t seem to have this problem.
			if(has(&quot;ie&quot;) || has(&quot;trident&quot;)){
				this.defer(function(){
					if(!focus.curNode){
						this.ownerDocumentBody.focus();
					}
				});
			}

			this.inherited(arguments);

			var newValue = this.getValue(true);
			if(newValue !== this.value){
				this.onChange(newValue);
			}
			this._set(&quot;value&quot;, newValue);
		},

		_onFocus: function(/*Event*/ e){
			// summary:
			//		Called from focus manager when focus has moved into this editor
			// tags:
			//		protected

			// console.info(&#x27;_onFocus&#x27;)
			if(!this.disabled){
				if(!this._disabledOK){
					this.set(&#x27;disabled&#x27;, false);
				}
				this.inherited(arguments);
			}
		},

		// TODO: remove in 2.0
		blur: function(){
			// summary:
			//		Remove focus from this instance.
			// tags:
			//		deprecated
			if(!has(&quot;ie&quot;) &amp;&amp; this.window.document.documentElement &amp;&amp; this.window.document.documentElement.focus){
				this.window.document.documentElement.focus();
			}else if(this.ownerDocumentBody.focus){
				this.ownerDocumentBody.focus();
			}
		},

		focus: function(){
			// summary:
			//		Move focus to this editor
			if(!this.isLoaded){
				this.focusOnLoad = true;
				return;
			}
			if(has(&quot;ie&quot;) &lt; 9){
				//this.editNode.focus(); -&gt; causes IE to scroll always (strict and quirks mode) to the top the Iframe
				// if we fire the event manually and let the browser handle the focusing, the latest
				// cursor position is focused like in FF
				this.iframe.fireEvent(&#x27;onfocus&#x27;, document.createEventObject()); // createEventObject/fireEvent only in IE &lt; 11
			}else{
				// Firefox and chrome
				this.editNode.focus();
			}
		},

		// _lastUpdate: 0,
		updateInterval: 200,
		_updateTimer: null,
		onDisplayChanged: function(/*Event*/ /*===== e =====*/){
			// summary:
			//		This event will be fired every time the display context
			//		changes and the result needs to be reflected in the UI.
			// description:
			//		If you don&#x27;t want to have update too often,
			//		onNormalizedDisplayChanged should be used instead
			// tags:
			//		private

			// var _t=new Date();
			if(this._updateTimer){
				this._updateTimer.remove();
			}
			this._updateTimer = this.defer(&quot;onNormalizedDisplayChanged&quot;, this.updateInterval);

			// Technically this should trigger a call to watch(&quot;value&quot;, ...) registered handlers,
			// but getValue() is too slow to call on every keystroke so we don&#x27;t.
		},
		onNormalizedDisplayChanged: function(){
			// summary:
			//		This event is fired every updateInterval ms or more
			// description:
			//		If something needs to happen immediately after a
			//		user change, please use onDisplayChanged instead.
			// tags:
			//		private
			delete this._updateTimer;
		},
		onChange: function(/*===== newContent =====*/){
			// summary:
			//		This is fired if and only if the editor loses focus and
			//		the content is changed.
		},
		_normalizeCommand: function(/*String*/ cmd, /*Anything?*/argument){
			// summary:
			//		Used as the advice function to map our
			//		normalized set of commands to those supported by the target
			//		browser.
			// tags:
			//		private

			var command = cmd.toLowerCase();
			if(command === &quot;formatblock&quot;){
				if(has(&quot;safari&quot;) &amp;&amp; argument === undefined){
					command = &quot;heading&quot;;
				}
			}else if(command === &quot;hilitecolor&quot; &amp;&amp; !has(&quot;mozilla&quot;)){
				command = &quot;backcolor&quot;;
			}

			return command;
		},

		_qcaCache: {},
		queryCommandAvailable: function(/*String*/ command){
			// summary:
			//		Tests whether a command is supported by the host. Clients
			//		SHOULD check whether a command is supported before attempting
			//		to use it, behaviour for unsupported commands is undefined.
			// command:
			//		The command to test for
			// tags:
			//		private

			// memoizing version. See _queryCommandAvailable for computing version
			var ca = this._qcaCache[command];
			if(ca !== undefined){
				return ca;
			}
			return (this._qcaCache[command] = this._queryCommandAvailable(command));
		},

		_queryCommandAvailable: function(/*String*/ command){
			// summary:
			//		See queryCommandAvailable().
			// tags:
			//		private

			switch(command.toLowerCase()){
				case &quot;bold&quot;:
				case &quot;italic&quot;:
				case &quot;underline&quot;:
				case &quot;subscript&quot;:
				case &quot;superscript&quot;:
				case &quot;fontname&quot;:
				case &quot;fontsize&quot;:
				case &quot;forecolor&quot;:
				case &quot;hilitecolor&quot;:
				case &quot;justifycenter&quot;:
				case &quot;justifyfull&quot;:
				case &quot;justifyleft&quot;:
				case &quot;justifyright&quot;:
				case &quot;delete&quot;:
				case &quot;selectall&quot;:
				case &quot;toggledir&quot;:

				case &quot;createlink&quot;:
				case &quot;unlink&quot;:
				case &quot;removeformat&quot;:
				case &quot;inserthorizontalrule&quot;:
				case &quot;insertimage&quot;:
				case &quot;insertorderedlist&quot;:
				case &quot;insertunorderedlist&quot;:
				case &quot;indent&quot;:
				case &quot;outdent&quot;:
				case &quot;formatblock&quot;:
				case &quot;inserthtml&quot;:
				case &quot;undo&quot;:
				case &quot;redo&quot;:
				case &quot;strikethrough&quot;:
				case &quot;tabindent&quot;:

				case &quot;cut&quot;:
				case &quot;copy&quot;:
				case &quot;paste&quot;:
					return true;

				// Note: This code path is apparently never called.  Not sure if it should return true or false
				// for Edge.
				case &quot;blockdirltr&quot;:
				case &quot;blockdirrtl&quot;:
				case &quot;dirltr&quot;:
				case &quot;dirrtl&quot;:
				case &quot;inlinedirltr&quot;:
				case &quot;inlinedirrtl&quot;:
					return has(&quot;ie&quot;) || has(&quot;trident&quot;) || has(&quot;edge&quot;);

				// Note: This code path is apparently never called, not even by the dojox/editor table plugins.
				// There&#x27;s also an _inserttableEnabledImpl() method that&#x27;s also never called.
				// Previously this code returned truthy for IE and mozilla, but false for chrome/safari, so
				// leaving it that way just in case.
				case &quot;inserttable&quot;:
				case &quot;insertcell&quot;:
				case &quot;insertcol&quot;:
				case &quot;insertrow&quot;:
				case &quot;deletecells&quot;:
				case &quot;deletecols&quot;:
				case &quot;deleterows&quot;:
				case &quot;mergecells&quot;:
				case &quot;splitcell&quot;:
					return !has(&quot;webkit&quot;);

				default:
					return false;
			}
		},

		execCommand: function(/*String*/ command, argument){
			// summary:
			//		Executes a command in the Rich Text area
			// command:
			//		The command to execute
			// argument:
			//		An optional argument to the command
			// tags:
			//		protected
			var returnValue;

			//focus() is required for IE to work
			//In addition, focus() makes sure after the execution of
			//the command, the editor receives the focus as expected
			if(this.focused){
				// put focus back in the iframe, unless focus has somehow been shifted out of the editor completely
				this.focus();
			}

			command = this._normalizeCommand(command, argument);

			if(argument !== undefined){
				if(command === &quot;heading&quot;){
					throw new Error(&quot;unimplemented&quot;);
				}else if(command === &quot;formatblock&quot; &amp;&amp; (has(&quot;ie&quot;) || has(&quot;trident&quot;))){
					// See http://stackoverflow.com/questions/10741831/execcommand-formatblock-headings-in-ie.
					// Not necessary on Edge though.
					argument = &#x27;&lt;&#x27; + argument + &#x27;&gt;&#x27;;
				}
			}

			//Check to see if we have any over-rides for commands, they will be functions on this
			//widget of the form _commandImpl.  If we don&#x27;t, fall through to the basic native
			//exec command of the browser.
			var implFunc = &quot;_&quot; + command + &quot;Impl&quot;;
			if(this[implFunc]){
				returnValue = this[implFunc](argument);
			}else{
				argument = arguments.length &gt; 1 ? argument : null;
				if(argument || command !== &quot;createlink&quot;){
					returnValue = this.document.execCommand(command, false, argument);
				}
			}

			this.onDisplayChanged();
			return returnValue;
		},

		queryCommandEnabled: function(/*String*/ command){
			// summary:
			//		Check whether a command is enabled or not.
			// command:
			//		The command to execute
			// tags:
			//		protected
			if(this.disabled || !this._disabledOK){
				return false;
			}

			command = this._normalizeCommand(command);

			//Check to see if we have any over-rides for commands, they will be functions on this
			//widget of the form _commandEnabledImpl.  If we don&#x27;t, fall through to the basic native
			//command of the browser.
			var implFunc = &quot;_&quot; + command + &quot;EnabledImpl&quot;;

			if(this[implFunc]){
				return  this[implFunc](command);
			}else{
				return this._browserQueryCommandEnabled(command);
			}
		},

		queryCommandState: function(command){
			// summary:
			//		Check the state of a given command and returns true or false.
			// tags:
			//		protected

			if(this.disabled || !this._disabledOK){
				return false;
			}
			command = this._normalizeCommand(command);
			try{
				return this.document.queryCommandState(command);
			}catch(e){
				//Squelch, occurs if editor is hidden on FF 3 (and maybe others.)
				return false;
			}
		},

		queryCommandValue: function(command){
			// summary:
			//		Check the value of a given command. This matters most for
			//		custom selections and complex values like font value setting.
			// tags:
			//		protected

			if(this.disabled || !this._disabledOK){
				return false;
			}
			var r;
			command = this._normalizeCommand(command);
			if(has(&quot;ie&quot;) &amp;&amp; command === &quot;formatblock&quot;){
				// This is to deal with IE bug when running in non-English.  See _localizeEditorCommands().
				// Apparently not needed on IE11 or Edge.
				r = this._native2LocalFormatNames[this.document.queryCommandValue(command)];
			}else if(has(&quot;mozilla&quot;) &amp;&amp; command === &quot;hilitecolor&quot;){
				var oldValue;
				try{
					oldValue = this.document.queryCommandValue(&quot;styleWithCSS&quot;);
				}catch(e){
					oldValue = false;
				}
				this.document.execCommand(&quot;styleWithCSS&quot;, false, true);
				r = this.document.queryCommandValue(command);
				this.document.execCommand(&quot;styleWithCSS&quot;, false, oldValue);
			}else{
				r = this.document.queryCommandValue(command);
			}
			return r;
		},

		// Misc.

		_sCall: function(name, args){
			// summary:
			//		Deprecated, remove for 2.0.   New code should access this.selection directly.
			//		Run the named method of dijit/selection over the
			//		current editor instance&#x27;s window, with the passed args.
			// tags:
			//		private deprecated

			return this.selection[name].apply(this.selection, args);
		},

		// FIXME: this is a TON of code duplication. Why?

		placeCursorAtStart: function(){
			// summary:
			//		Place the cursor at the start of the editing area.
			// tags:
			//		private

			this.focus();

			//see comments in placeCursorAtEnd
			var isvalid = false;
			if(has(&quot;mozilla&quot;)){
				// TODO:  Is this branch even necessary?
				var first = this.editNode.firstChild;
				while(first){
					if(first.nodeType === 3){
						if(first.nodeValue.replace(/^\s+|\s+$/g, &quot;&quot;).length &gt; 0){
							isvalid = true;
							this.selection.selectElement(first);
							break;
						}
					}else if(first.nodeType === 1){
						isvalid = true;
						var tg = first.tagName ? first.tagName.toLowerCase() : &quot;&quot;;
						// Collapse before childless tags.
						if(/br|input|img|base|meta|area|basefont|hr|link/.test(tg)){
							this.selection.selectElement(first);
						}else{
							// Collapse inside tags with children.
							this.selection.selectElementChildren(first);
						}
						break;
					}
					first = first.nextSibling;
				}
			}else{
				isvalid = true;
				this.selection.selectElementChildren(this.editNode);
			}
			if(isvalid){
				this.selection.collapse(true);
			}
		},

		placeCursorAtEnd: function(){
			// summary:
			//		Place the cursor at the end of the editing area.
			// tags:
			//		private

			this.focus();

			//In mozilla, if last child is not a text node, we have to use
			// selectElementChildren on this.editNode.lastChild otherwise the
			// cursor would be placed at the end of the closing tag of
			//this.editNode.lastChild
			var isvalid = false;
			if(has(&quot;mozilla&quot;)){
				var last = this.editNode.lastChild;
				while(last){
					if(last.nodeType === 3){
						if(last.nodeValue.replace(/^\s+|\s+$/g, &quot;&quot;).length &gt; 0){
							isvalid = true;
							this.selection.selectElement(last);
							break;
						}
					}else if(last.nodeType === 1){
						isvalid = true;
						this.selection.selectElement(last.lastChild || last);
						break;
					}
					last = last.previousSibling;
				}
			}else{
				isvalid = true;
				this.selection.selectElementChildren(this.editNode);
			}
			if(isvalid){
				this.selection.collapse(false);
			}
		},

		getValue: function(/*Boolean?*/ nonDestructive){
			// summary:
			//		Return the current content of the editing area (post filters
			//		are applied).  Users should call get(&#x27;value&#x27;) instead.
			// nonDestructive:
			//		defaults to false. Should the post-filtering be run over a copy
			//		of the live DOM? Most users should pass &quot;true&quot; here unless they
			//		*really* know that none of the installed filters are going to
			//		mess up the editing session.
			// tags:
			//		private
			if(this.textarea){
				if(this.isClosed || !this.isLoaded){
					return this.textarea.value;
				}
			}

			return this.isLoaded ? this._postFilterContent(null, nonDestructive) : this.value;
		},
		_getValueAttr: function(){
			// summary:
			//		Hook to make attr(&quot;value&quot;) work
			return this.getValue(true);
		},

		setValue: function(/*String*/ html){
			// summary:
			//		This function sets the content. No undo history is preserved.
			//		Users should use set(&#x27;value&#x27;, ...) instead.
			// tags:
			//		deprecated

			// TODO: remove this and getValue() for 2.0, and move code to _setValueAttr()

			if(!this.isLoaded){
				// try again after the editor is finished loading
				this.onLoadDeferred.then(lang.hitch(this, function(){
					this.setValue(html);
				}));
				return;
			}
			if(this.textarea &amp;&amp; (this.isClosed || !this.isLoaded)){
				this.textarea.value = html;
			}else{
				html = this._preFilterContent(html);
				var node = this.isClosed ? this.domNode : this.editNode;

				node.innerHTML = html;
				this._preDomFilterContent(node);
			}

			this.onDisplayChanged();
			this._set(&quot;value&quot;, this.getValue(true));
		},

		replaceValue: function(/*String*/ html){
			// summary:
			//		This function set the content while trying to maintain the undo stack
			//		(now only works fine with Moz, this is identical to setValue in all
			//		other browsers)
			// tags:
			//		protected

			if(this.isClosed){
				this.setValue(html);
			}else if(this.window &amp;&amp; this.window.getSelection &amp;&amp; !has(&quot;mozilla&quot;)){ // Safari
				// look ma! it&#x27;s a totally f&#x27;d browser!
				this.setValue(html);
			}else if(this.window &amp;&amp; this.window.getSelection){ // Moz
				html = this._preFilterContent(html);
				this.execCommand(&quot;selectall&quot;);
				this.execCommand(&quot;inserthtml&quot;, html);
				this._preDomFilterContent(this.editNode);
			}else if(this.document &amp;&amp; this.document.selection){//IE
				//In IE, when the first element is not a text node, say
				//an &lt;a&gt; tag, when replacing the content of the editing
				//area, the &lt;a&gt; tag will be around all the content
				//so for now, use setValue for IE too
				this.setValue(html);
			}

			this._set(&quot;value&quot;, this.getValue(true));
		},

		_preFilterContent: function(/*String*/ html){
			// summary:
			//		Filter the input before setting the content of the editing
			//		area. DOM pre-filtering may happen after this
			//		string-based filtering takes place but as of 1.2, this is not
			//		guaranteed for operations such as the inserthtml command.
			// tags:
			//		private

			var ec = html;
			array.forEach(this.contentPreFilters, function(ef){
				if(ef){
					ec = ef(ec);
				}
			});
			return ec;
		},
		_preDomFilterContent: function(/*DomNode*/ dom){
			// summary:
			//		filter the input&#x27;s live DOM. All filter operations should be
			//		considered to be &quot;live&quot; and operating on the DOM that the user
			//		will be interacting with in their editing session.
			// tags:
			//		private
			dom = dom || this.editNode;
			array.forEach(this.contentDomPreFilters, function(ef){
				if(ef &amp;&amp; lang.isFunction(ef)){
					ef(dom);
				}
			}, this);
		},

		_postFilterContent: function(/*DomNode|DomNode[]|String?*/ dom, /*Boolean?*/ nonDestructive){
			// summary:
			//		filter the output after getting the content of the editing area
			//
			// description:
			//		post-filtering allows plug-ins and users to specify any number
			//		of transforms over the editor&#x27;s content, enabling many common
			//		use-cases such as transforming absolute to relative URLs (and
			//		vice-versa), ensuring conformance with a particular DTD, etc.
			//		The filters are registered in the contentDomPostFilters and
			//		contentPostFilters arrays. Each item in the
			//		contentDomPostFilters array is a function which takes a DOM
			//		Node or array of nodes as its only argument and returns the
			//		same. It is then passed down the chain for further filtering.
			//		The contentPostFilters array behaves the same way, except each
			//		member operates on strings. Together, the DOM and string-based
			//		filtering allow the full range of post-processing that should
			//		be necessaray to enable even the most agressive of post-editing
			//		conversions to take place.
			//
			//		If nonDestructive is set to &quot;true&quot;, the nodes are cloned before
			//		filtering proceeds to avoid potentially destructive transforms
			//		to the content which may still needed to be edited further.
			//		Once DOM filtering has taken place, the serialized version of
			//		the DOM which is passed is run through each of the
			//		contentPostFilters functions.
			//
			// dom:
			//		a node, set of nodes, which to filter using each of the current
			//		members of the contentDomPostFilters and contentPostFilters arrays.
			//
			// nonDestructive:
			//		defaults to &quot;false&quot;. If true, ensures that filtering happens on
			//		a clone of the passed-in content and not the actual node
			//		itself.
			//
			// tags:
			//		private

			var ec;
			if(!lang.isString(dom)){
				dom = dom || this.editNode;
				if(this.contentDomPostFilters.length){
					if(nonDestructive){
						dom = lang.clone(dom);
					}
					array.forEach(this.contentDomPostFilters, function(ef){
						dom = ef(dom);
					});
				}
				ec = htmlapi.getChildrenHtml(dom);
			}else{
				ec = dom;
			}

			if(!lang.trim(ec.replace(/^\xA0\xA0*/, &#x27;&#x27;).replace(/\xA0\xA0*$/, &#x27;&#x27;)).length){
				ec = &quot;&quot;;
			}

			array.forEach(this.contentPostFilters, function(ef){
				ec = ef(ec);
			});

			return ec;
		},

		_saveContent: function(){
			// summary:
			//		Saves the content in an onunload event if the editor has not been closed
			// tags:
			//		private

			var saveTextarea = dom.byId(dijit._scopeName + &quot;._editor.RichText.value&quot;);
			if(saveTextarea){
				if(saveTextarea.value){
					saveTextarea.value += this._SEPARATOR;
				}
				saveTextarea.value += this.name + this._NAME_CONTENT_SEP + this.getValue(true);
			}
		},


		escapeXml: function(/*String*/ str, /*Boolean*/ noSingleQuotes){
			// summary:
			//		Adds escape sequences for special characters in XML.
			//		Optionally skips escapes for single quotes
			// tags:
			//		private

			str = str.replace(/&amp;/gm, &quot;&amp;amp;&quot;).replace(/&lt;/gm, &quot;&amp;lt;&quot;).replace(/&gt;/gm, &quot;&amp;gt;&quot;).replace(/&quot;/gm, &quot;&amp;quot;&quot;);
			if(!noSingleQuotes){
				str = str.replace(/&#x27;/gm, &quot;&amp;#39;&quot;);
			}
			return str; // string
		},

		getNodeHtml: function(/* DomNode */ node){
			// summary:
			//		Deprecated.   Use dijit/_editor/html::_getNodeHtml() instead.
			// tags:
			//		deprecated
			kernel.deprecated(&#x27;dijit.Editor::getNodeHtml is deprecated&#x27;, &#x27;use dijit/_editor/html::getNodeHtml instead&#x27;, 2);
			return htmlapi.getNodeHtml(node); // String
		},

		getNodeChildrenHtml: function(/* DomNode */ dom){
			// summary:
			//		Deprecated.   Use dijit/_editor/html::getChildrenHtml() instead.
			// tags:
			//		deprecated
			kernel.deprecated(&#x27;dijit.Editor::getNodeChildrenHtml is deprecated&#x27;, &#x27;use dijit/_editor/html::getChildrenHtml instead&#x27;, 2);
			return htmlapi.getChildrenHtml(dom);
		},

		close: function(/*Boolean?*/ save){
			// summary:
			//		Kills the editor and optionally writes back the modified contents to the
			//		element from which it originated.
			// save:
			//		Whether or not to save the changes. If false, the changes are discarded.
			// tags:
			//		private

			if(this.isClosed){
				return;
			}

			if(!arguments.length){
				save = true;
			}
			if(save){
				this._set(&quot;value&quot;, this.getValue(true));
			}

			// line height is squashed for iframes
			// FIXME: why was this here? if(this.iframe){ this.domNode.style.lineHeight = null; }

			if(this.interval){
				clearInterval(this.interval);
			}

			if(this._webkitListener){
				// Cleanup of WebKit fix: #9532
				this._webkitListener.remove();
				delete this._webkitListener;
			}

			// Guard against memory leaks on IE (see #9268)
			if(has(&quot;ie&quot;)){
				this.iframe.onfocus = null;
			}
			this.iframe._loadFunc = null;

			if(this._iframeRegHandle){
				this._iframeRegHandle.remove();
				delete this._iframeRegHandle;
			}

			if(this.textarea){
				var s = this.textarea.style;
				s.position = &quot;&quot;;
				s.left = s.top = &quot;&quot;;
				if(has(&quot;ie&quot;)){
					s.overflow = this.__overflow;
					this.__overflow = null;
				}
				this.textarea.value = this.value;
				domConstruct.destroy(this.domNode);
				this.domNode = this.textarea;
			}else{
				// Note that this destroys the iframe
				this.domNode.innerHTML = this.value;
			}
			delete this.iframe;

			domClass.remove(this.domNode, this.baseClass);
			this.isClosed = true;
			this.isLoaded = false;

			delete this.editNode;
			delete this.focusNode;

			if(this.window &amp;&amp; this.window._frameElement){
				this.window._frameElement = null;
			}

			this.window = null;
			this.document = null;
			this.editingArea = null;
			this.editorObject = null;
		},

		destroy: function(){
			if(!this.isClosed){
				this.close(false);
			}
			if(this._updateTimer){
				this._updateTimer.remove();
			}
			this.inherited(arguments);
			if(RichText._globalSaveHandler){
				delete RichText._globalSaveHandler[this.id];
			}
		},

		_removeMozBogus: function(/* String */ html){
			// summary:
			//		Post filter to remove unwanted HTML attributes generated by mozilla
			// tags:
			//		private
			return html.replace(/\stype=&quot;_moz&quot;/gi, &#x27;&#x27;).replace(/\s_moz_dirty=&quot;&quot;/gi, &#x27;&#x27;).replace(/_moz_resizing=&quot;(true|false)&quot;/gi, &#x27;&#x27;); // String
		},
		_removeWebkitBogus: function(/* String */ html){
			// summary:
			//		Post filter to remove unwanted HTML attributes generated by webkit
			// tags:
			//		private
			html = html.replace(/\sclass=&quot;webkit-block-placeholder&quot;/gi, &#x27;&#x27;);
			html = html.replace(/\sclass=&quot;apple-style-span&quot;/gi, &#x27;&#x27;);
			// For some reason copy/paste sometime adds extra meta tags for charset on
			// webkit (chrome) on mac.They need to be removed.  See: #12007&quot;
			html = html.replace(/&lt;meta charset=\&quot;utf-8\&quot; \/&gt;/gi, &#x27;&#x27;);
			return html; // String
		},
		_normalizeFontStyle: function(/* String */ html){
			// summary:
			//		Convert &#x27;strong&#x27; and &#x27;em&#x27; to &#x27;b&#x27; and &#x27;i&#x27;.
			// description:
			//		Moz can not handle strong/em tags correctly, so to help
			//		mozilla and also to normalize output, convert them to &#x27;b&#x27; and &#x27;i&#x27;.
			//
			//		Note the IE generates &#x27;strong&#x27; and &#x27;em&#x27; rather than &#x27;b&#x27; and &#x27;i&#x27;
			// tags:
			//		private
			return html.replace(/&lt;(\/)?strong([ \&gt;])/gi, &#x27;&lt;$1b$2&#x27;)
				.replace(/&lt;(\/)?em([ \&gt;])/gi, &#x27;&lt;$1i$2&#x27;); // String
		},

		_preFixUrlAttributes: function(/* String */ html){
			// summary:
			//		Pre-filter to do fixing to href attributes on &#x60;&lt;a&gt;&#x60; and &#x60;&lt;img&gt;&#x60; tags
			// tags:
			//		private
			return html.replace(/(?:(&lt;a(?=\s).*?\shref=)(&quot;|&#x27;)(.*?)\2)|(?:(&lt;a\s.*?href=)([^&quot;&#x27;][^ &gt;]+))/gi,
				&#x27;$1$4$2$3$5$2 _djrealurl=$2$3$5$2&#x27;)
				.replace(/(?:(&lt;img(?=\s).*?\ssrc=)(&quot;|&#x27;)(.*?)\2)|(?:(&lt;img\s.*?src=)([^&quot;&#x27;][^ &gt;]+))/gi,
				&#x27;$1$4$2$3$5$2 _djrealurl=$2$3$5$2&#x27;); // String
		},

		/*****************************************************************************
		 The following functions implement HTML manipulation commands for various
		 browser/contentEditable implementations.  The goal of them is to enforce
		 standard behaviors of them.
		 ******************************************************************************/

		/*** queryCommandEnabled implementations ***/

		_browserQueryCommandEnabled: function(command){
			// summary:
			//		Implementation to call to the native queryCommandEnabled of the browser.
			// command:
			//		The command to check.
			// tags:
			//		protected
			if(!command){
				return false;
			}
			var elem = has(&quot;ie&quot;) &lt; 9 ? this.document.selection.createRange() : this.document;
			try{
				return elem.queryCommandEnabled(command);
			}catch(e){
				return false;
			}
		},

		_createlinkEnabledImpl: function(/*===== argument =====*/){
			// summary:
			//		This function implements the test for if the create link
			//		command should be enabled or not.
			// argument:
			//		arguments to the exec command, if any.
			// tags:
			//		protected
			var enabled = true;
			if(has(&quot;opera&quot;)){
				var sel = this.window.getSelection();
				if(sel.isCollapsed){
					enabled = true;
				}else{
					enabled = this.document.queryCommandEnabled(&quot;createlink&quot;);
				}
			}else{
				enabled = this._browserQueryCommandEnabled(&quot;createlink&quot;);
			}
			return enabled;
		},

		_unlinkEnabledImpl: function(/*===== argument =====*/){
			// summary:
			//		This function implements the test for if the unlink
			//		command should be enabled or not.
			// argument:
			//		arguments to the exec command, if any.
			// tags:
			//		protected
			var enabled = true;
			if(has(&quot;mozilla&quot;) || has(&quot;webkit&quot;)){
				enabled = this.selection.hasAncestorElement(&quot;a&quot;);
			}else{
				enabled = this._browserQueryCommandEnabled(&quot;unlink&quot;);
			}
			return enabled;
		},

		_inserttableEnabledImpl: function(/*===== argument =====*/){
			// summary:
			//		This function implements the test for if the inserttable
			//		command should be enabled or not.
			// argument:
			//		arguments to the exec command, if any.
			// tags:
			//		protected
			var enabled = true;
			if(has(&quot;mozilla&quot;) || has(&quot;webkit&quot;)){
				enabled = true;
			}else{
				enabled = this._browserQueryCommandEnabled(&quot;inserttable&quot;);
			}
			return enabled;
		},

		_cutEnabledImpl: function(/*===== argument =====*/){
			// summary:
			//		This function implements the test for if the cut
			//		command should be enabled or not.
			// argument:
			//		arguments to the exec command, if any.
			// tags:
			//		protected
			var enabled = true;
			if(has(&quot;webkit&quot;)){
				// WebKit deems clipboard activity as a security threat and natively would return false
				var sel = this.window.getSelection();
				if(sel){
					sel = sel.toString();
				}
				enabled = !!sel;
			}else{
				enabled = this._browserQueryCommandEnabled(&quot;cut&quot;);
			}
			return enabled;
		},

		_copyEnabledImpl: function(/*===== argument =====*/){
			// summary:
			//		This function implements the test for if the copy
			//		command should be enabled or not.
			// argument:
			//		arguments to the exec command, if any.
			// tags:
			//		protected
			var enabled = true;
			if(has(&quot;webkit&quot;)){
				// WebKit deems clipboard activity as a security threat and natively would return false
				var sel = this.window.getSelection();
				if(sel){
					sel = sel.toString();
				}
				enabled = !!sel;
			}else{
				enabled = this._browserQueryCommandEnabled(&quot;copy&quot;);
			}
			return enabled;
		},

		_pasteEnabledImpl: function(/*===== argument =====*/){
			// summary:c
			//		This function implements the test for if the paste
			//		command should be enabled or not.
			// argument:
			//		arguments to the exec command, if any.
			// tags:
			//		protected
			var enabled = true;
			if(has(&quot;webkit&quot;)){
				return true;
			}else{
				enabled = this._browserQueryCommandEnabled(&quot;paste&quot;);
			}
			return enabled;
		},

		/*** execCommand implementations ***/

		_inserthorizontalruleImpl: function(argument){
			// summary:
			//		This function implements the insertion of HTML &#x27;HR&#x27; tags.
			//		into a point on the page.  IE doesn&#x27;t to it right, so
			//		we have to use an alternate form
			// argument:
			//		arguments to the exec command, if any.
			// tags:
			//		protected
			if(has(&quot;ie&quot;)){
				return this._inserthtmlImpl(&quot;&lt;hr&gt;&quot;);
			}
			return this.document.execCommand(&quot;inserthorizontalrule&quot;, false, argument);
		},

		_unlinkImpl: function(argument){
			// summary:
			//		This function implements the unlink of an &#x27;a&#x27; tag.
			// argument:
			//		arguments to the exec command, if any.
			// tags:
			//		protected
			if((this.queryCommandEnabled(&quot;unlink&quot;)) &amp;&amp; (has(&quot;mozilla&quot;) || has(&quot;webkit&quot;))){
				var a = this.selection.getAncestorElement(&quot;a&quot;);
				this.selection.selectElement(a);
				return this.document.execCommand(&quot;unlink&quot;, false, null);
			}
			return this.document.execCommand(&quot;unlink&quot;, false, argument);
		},

		_hilitecolorImpl: function(argument){
			// summary:
			//		This function implements the hilitecolor command
			// argument:
			//		arguments to the exec command, if any.
			// tags:
			//		protected
			var returnValue;
			var isApplied = this._handleTextColorOrProperties(&quot;hilitecolor&quot;, argument);
			if(!isApplied){
				if(has(&quot;mozilla&quot;)){
					// mozilla doesn&#x27;t support hilitecolor properly when useCSS is
					// set to false (bugzilla #279330)
					this.document.execCommand(&quot;styleWithCSS&quot;, false, true);
					console.log(&quot;Executing color command.&quot;);
					returnValue = this.document.execCommand(&quot;hilitecolor&quot;, false, argument);
					this.document.execCommand(&quot;styleWithCSS&quot;, false, false);
				}else{
					returnValue = this.document.execCommand(&quot;hilitecolor&quot;, false, argument);
				}
			}
			return returnValue;
		},

		_backcolorImpl: function(argument){
			// summary:
			//		This function implements the backcolor command
			// argument:
			//		arguments to the exec command, if any.
			// tags:
			//		protected
			if(has(&quot;ie&quot;)){
				// Tested under IE 6 XP2, no problem here, comment out
				// IE weirdly collapses ranges when we exec these commands, so prevent it
				//	var tr = this.document.selection.createRange();
				argument = argument ? argument : null;
			}
			var isApplied = this._handleTextColorOrProperties(&quot;backcolor&quot;, argument);
			if(!isApplied){
				isApplied = this.document.execCommand(&quot;backcolor&quot;, false, argument);
			}
			return isApplied;
		},

		_forecolorImpl: function(argument){
			// summary:
			//		This function implements the forecolor command
			// argument:
			//		arguments to the exec command, if any.
			// tags:
			//		protected
			if(has(&quot;ie&quot;)){
				// Tested under IE 6 XP2, no problem here, comment out
				// IE weirdly collapses ranges when we exec these commands, so prevent it
				//	var tr = this.document.selection.createRange();
				argument = argument ? argument : null;
			}
			var isApplied = false;
			isApplied = this._handleTextColorOrProperties(&quot;forecolor&quot;, argument);
			if(!isApplied){
				isApplied = this.document.execCommand(&quot;forecolor&quot;, false, argument);
			}
			return isApplied;
		},

		_inserthtmlImpl: function(argument){
			// summary:
			//		This function implements the insertion of HTML content into
			//		a point on the page.
			// argument:
			//		The content to insert, if any.
			// tags:
			//		protected
			argument = this._preFilterContent(argument);
			var rv = true;
			if(has(&quot;ie&quot;) &lt; 9){
				var insertRange = this.document.selection.createRange();
				if(this.document.selection.type.toUpperCase() === &#x27;CONTROL&#x27;){
					var n = insertRange.item(0);
					while(insertRange.length){
						insertRange.remove(insertRange.item(0));
					}
					n.outerHTML = argument;
				}else{
					insertRange.pasteHTML(argument);
				}
				insertRange.select();
			}else if(has(&quot;trident&quot;) &lt; 8){
				var insertRange;
				var selection = rangeapi.getSelection(this.window);
				if(selection &amp;&amp; selection.rangeCount &amp;&amp; selection.getRangeAt){
					insertRange = selection.getRangeAt(0);
					insertRange.deleteContents();

					var div = domConstruct.create(&#x27;div&#x27;);
					div.innerHTML = argument;
					var node, lastNode;
					var n = this.document.createDocumentFragment();
					while((node = div.firstChild)){
						lastNode = n.appendChild(node);
					}
					insertRange.insertNode(n);
					if(lastNode) {
						insertRange = insertRange.cloneRange();
						insertRange.setStartAfter(lastNode);
						insertRange.collapse(false);
						selection.removeAllRanges();
						selection.addRange(insertRange);
					}
				}
			}else if(has(&quot;mozilla&quot;) &amp;&amp; !argument.length){
				//mozilla can not inserthtml an empty html to delete current selection
				//so we delete the selection instead in this case
				this.selection.remove(); // FIXME
			}else{
				rv = this.document.execCommand(&quot;inserthtml&quot;, false, argument);
			}
			return rv;
		},

		_boldImpl: function(argument){
			// summary:
			//		This function implements an over-ride of the bold command.
			// argument:
			//		Not used, operates by selection.
			// tags:
			//		protected
			var applied = false;
			if(has(&quot;ie&quot;) || has(&quot;trident&quot;)){
				this._adaptIESelection();
				applied = this._adaptIEFormatAreaAndExec(&quot;bold&quot;);
			}
			if(!applied){
				applied = this.document.execCommand(&quot;bold&quot;, false, argument);
			}
			return applied;
		},

		_italicImpl: function(argument){
			// summary:
			//		This function implements an over-ride of the italic command.
			// argument:
			//		Not used, operates by selection.
			// tags:
			//		protected
			var applied = false;
			if(has(&quot;ie&quot;) || has(&quot;trident&quot;)){
				this._adaptIESelection();
				applied = this._adaptIEFormatAreaAndExec(&quot;italic&quot;);
			}
			if(!applied){
				applied = this.document.execCommand(&quot;italic&quot;, false, argument);
			}
			return applied;
		},

		_underlineImpl: function(argument){
			// summary:
			//		This function implements an over-ride of the underline command.
			// argument:
			//		Not used, operates by selection.
			// tags:
			//		protected
			var applied = false;
			if(has(&quot;ie&quot;) || has(&quot;trident&quot;)){
				this._adaptIESelection();
				applied = this._adaptIEFormatAreaAndExec(&quot;underline&quot;);
			}
			if(!applied){
				applied = this.document.execCommand(&quot;underline&quot;, false, argument);
			}
			return applied;
		},

		_strikethroughImpl: function(argument){
			// summary:
			//		This function implements an over-ride of the strikethrough command.
			// argument:
			//		Not used, operates by selection.
			// tags:
			//		protected
			var applied = false;
			if(has(&quot;ie&quot;) || has(&quot;trident&quot;)){
				this._adaptIESelection();
				applied = this._adaptIEFormatAreaAndExec(&quot;strikethrough&quot;);
			}
			if(!applied){
				applied = this.document.execCommand(&quot;strikethrough&quot;, false, argument);
			}
			return applied;
		},

		_superscriptImpl: function(argument){
			// summary:
			//		This function implements an over-ride of the superscript command.
			// argument:
			//		Not used, operates by selection.
			// tags:
			//		protected
			var applied = false;
			if(has(&quot;ie&quot;) || has(&quot;trident&quot;)){
				this._adaptIESelection();
				applied = this._adaptIEFormatAreaAndExec(&quot;superscript&quot;);
			}
			if(!applied){
				applied = this.document.execCommand(&quot;superscript&quot;, false, argument);
			}
			return applied;
		},

		_subscriptImpl: function(argument){
			// summary:
			//		This function implements an over-ride of the superscript command.
			// argument:
			//		Not used, operates by selection.
			// tags:
			//		protected
			var applied = false;
			if(has(&quot;ie&quot;) || has(&quot;trident&quot;)){
				this._adaptIESelection();
				applied = this._adaptIEFormatAreaAndExec(&quot;subscript&quot;);

			}
			if(!applied){
				applied = this.document.execCommand(&quot;subscript&quot;, false, argument);
			}
			return applied;
		},

		_fontnameImpl: function(argument){
			// summary:
			//		This function implements the fontname command
			// argument:
			//		arguments to the exec command, if any.
			// tags:
			//		protected
			var isApplied;
			if(has(&quot;ie&quot;) || has(&quot;trident&quot;)){
				isApplied = this._handleTextColorOrProperties(&quot;fontname&quot;, argument);
			}
			if(!isApplied){
				isApplied = this.document.execCommand(&quot;fontname&quot;, false, argument);
			}
			return isApplied;
		},

		_fontsizeImpl: function(argument){
			// summary:
			//		This function implements the fontsize command
			// argument:
			//		arguments to the exec command, if any.
			// tags:
			//		protected
			var isApplied;
			if(has(&quot;ie&quot;) || has(&quot;trident&quot;)){
				isApplied = this._handleTextColorOrProperties(&quot;fontsize&quot;, argument);
			}
			if(!isApplied){
				isApplied = this.document.execCommand(&quot;fontsize&quot;, false, argument);
			}
			return isApplied;
		},

		_insertorderedlistImpl: function(argument){
			// summary:
			//		This function implements the insertorderedlist command
			// argument:
			//		arguments to the exec command, if any.
			// tags:
			//		protected
			var applied = false;
			if(has(&quot;ie&quot;) || has(&quot;trident&quot;) || has(&quot;edge&quot;)){
				applied = this._adaptIEList(&quot;insertorderedlist&quot;, argument);
			}
			if(!applied){
				applied = this.document.execCommand(&quot;insertorderedlist&quot;, false, argument);
			}
			return applied;
		},

		_insertunorderedlistImpl: function(argument){
			// summary:
			//		This function implements the insertunorderedlist command
			// argument:
			//		arguments to the exec command, if any.
			// tags:
			//		protected
			var applied = false;
			if(has(&quot;ie&quot;) || has(&quot;trident&quot;) || has(&quot;edge&quot;)){
				applied = this._adaptIEList(&quot;insertunorderedlist&quot;, argument);
			}
			if(!applied){
				applied = this.document.execCommand(&quot;insertunorderedlist&quot;, false, argument);
			}
			return applied;
		},

		getHeaderHeight: function(){
			// summary:
			//		A function for obtaining the height of the header node
			return this._getNodeChildrenHeight(this.header); // Number
		},

		getFooterHeight: function(){
			// summary:
			//		A function for obtaining the height of the footer node
			return this._getNodeChildrenHeight(this.footer); // Number
		},

		_getNodeChildrenHeight: function(node){
			// summary:
			//		An internal function for computing the cumulative height of all child nodes of &#x27;node&#x27;
			// node:
			//		The node to process the children of;
			var h = 0;
			if(node &amp;&amp; node.childNodes){
				// IE didn&#x27;t compute it right when position was obtained on the node directly is some cases,
				// so we have to walk over all the children manually.
				var i;
				for(i = 0; i &lt; node.childNodes.length; i++){
					var size = domGeometry.position(node.childNodes[i]);
					h += size.h;
				}
			}
			return h; // Number
		},

		_isNodeEmpty: function(node, startOffset){
			// summary:
			//		Function to test if a node is devoid of real content.
			// node:
			//		The node to check.
			// tags:
			//		private.
			if(node.nodeType === 1/*element*/){
				if(node.childNodes.length &gt; 0){
					return this._isNodeEmpty(node.childNodes[0], startOffset);	// huh?   why test just first child?
				}
				return true;
			}else if(node.nodeType === 3/*text*/){
				return (node.nodeValue.substring(startOffset) === &quot;&quot;);
			}
			return false;
		},

		_removeStartingRangeFromRange: function(node, range){
			// summary:
			//		Function to adjust selection range by removing the current
			//		start node.
			// node:
			//		The node to remove from the starting range.
			// range:
			//		The range to adapt.
			// tags:
			//		private
			if(node.nextSibling){
				range.setStart(node.nextSibling, 0);
			}else{
				var parent = node.parentNode;
				while(parent &amp;&amp; parent.nextSibling == null){
					//move up the tree until we find a parent that has another node, that node will be the next node
					parent = parent.parentNode;
				}
				if(parent){
					range.setStart(parent.nextSibling, 0);
				}
			}
			return range;
		},

		_adaptIESelection: function(){
			// summary:
			//		Function to adapt the IE range by removing leading &#x27;newlines&#x27;
			//		Needed to fix issue with bold/italics/underline not working if
			//		range included leading &#x27;newlines&#x27;.
			//		In IE, if a user starts a selection at the very end of a line,
			//		then the native browser commands will fail to execute correctly.
			//		To work around the issue,  we can remove all empty nodes from
			//		the start of the range selection.
			//
			//		Note: not needed on Edge because Windows 10 won&#x27;t let the user make
			//		a selection containing leading or trailing newlines.
			var selection = rangeapi.getSelection(this.window);
			if(selection &amp;&amp; selection.rangeCount &amp;&amp; !selection.isCollapsed){
				var range = selection.getRangeAt(0);
				var firstNode = range.startContainer;
				var startOffset = range.startOffset;

				while(firstNode.nodeType === 3/*text*/ &amp;&amp; startOffset &gt;= firstNode.length &amp;&amp; firstNode.nextSibling){
					//traverse the text nodes until we get to the one that is actually highlighted
					startOffset = startOffset - firstNode.length;
					firstNode = firstNode.nextSibling;
				}

				//Remove the starting ranges until the range does not start with an empty node.
				var lastNode = null;
				while(this._isNodeEmpty(firstNode, startOffset) &amp;&amp; firstNode !== lastNode){
					lastNode = firstNode; //this will break the loop in case we can&#x27;t find the next sibling
					range = this._removeStartingRangeFromRange(firstNode, range); //move the start container to the next node in the range
					firstNode = range.startContainer;
					startOffset = 0; //start at the beginning of the new starting range
				}
				selection.removeAllRanges();// this will work as long as users cannot select multiple ranges. I have not been able to do that in the editor.
				selection.addRange(range);
			}
		},

		_adaptIEFormatAreaAndExec: function(command){
			// summary:
			//		Function to handle IE&#x27;s quirkiness regarding how it handles
			//		format commands on a word.  This involves a lit of node splitting
			//		and format cloning.
			// command:
			//		The format command, needed to check if the desired
			//		command is true or not.
			var selection = rangeapi.getSelection(this.window);
			var doc = this.document;
			var rs, ret, range, txt, startNode, endNode, breaker, sNode;
			if(command &amp;&amp; selection &amp;&amp; selection.isCollapsed){
				var isApplied = this.queryCommandValue(command);
				if(isApplied){

					// We have to split backwards until we hit the format
					var nNames = this._tagNamesForCommand(command);
					range = selection.getRangeAt(0);
					var fs = range.startContainer;
					if(fs.nodeType === 3){
						var offset = range.endOffset;
						if(fs.length &lt; offset){
							//We are not looking from the right node, try to locate the correct one
							ret = this._adjustNodeAndOffset(rs, offset);
							fs = ret.node;
							offset = ret.offset;
						}
					}
					var topNode;
					while(fs &amp;&amp; fs !== this.editNode){
						// We have to walk back and see if this is still a format or not.
						// Hm, how do I do this?
						var tName = fs.tagName ? fs.tagName.toLowerCase() : &quot;&quot;;
						if(array.indexOf(nNames, tName) &gt; -1){
							topNode = fs;
							break;
						}
						fs = fs.parentNode;
					}

					// Okay, we have a stopping place, time to split things apart.
					if(topNode){
						// Okay, we know how far we have to split backwards, so we have to split now.
						rs = range.startContainer;
						var newblock = doc.createElement(topNode.tagName);
						domConstruct.place(newblock, topNode, &quot;after&quot;);
						if(rs &amp;&amp; rs.nodeType === 3){
							// Text node, we have to split it.
							var nodeToMove, tNode;
							var endOffset = range.endOffset;
							if(rs.length &lt; endOffset){
								//We are not splitting the right node, try to locate the correct one
								ret = this._adjustNodeAndOffset(rs, endOffset);
								rs = ret.node;
								endOffset = ret.offset;
							}

							txt = rs.nodeValue;
							startNode = doc.createTextNode(txt.substring(0, endOffset));
							var endText = txt.substring(endOffset, txt.length);
							if(endText){
								endNode = doc.createTextNode(endText);
							}
							// Place the split, then remove original nodes.
							domConstruct.place(startNode, rs, &quot;before&quot;);
							if(endNode){
								breaker = doc.createElement(&quot;span&quot;);
								breaker.className = &quot;ieFormatBreakerSpan&quot;;
								domConstruct.place(breaker, rs, &quot;after&quot;);
								domConstruct.place(endNode, breaker, &quot;after&quot;);
								endNode = breaker;
							}
							domConstruct.destroy(rs);

							// Okay, we split the text.  Now we need to see if we&#x27;re
							// parented to the block element we&#x27;re splitting and if
							// not, we have to split all the way up.  Ugh.
							var parentC = startNode.parentNode;
							var tagList = [];
							var tagData;
							while(parentC !== topNode){
								var tg = parentC.tagName;
								tagData = {tagName: tg};
								tagList.push(tagData);

								var newTg = doc.createElement(tg);
								// Clone over any &#x27;style&#x27; data.
								if(parentC.style){
									if(newTg.style){
										if(parentC.style.cssText){
											newTg.style.cssText = parentC.style.cssText;
											tagData.cssText = parentC.style.cssText;
										}
									}
								}
								// If font also need to clone over any font data.
								if(parentC.tagName === &quot;FONT&quot;){
									if(parentC.color){
										newTg.color = parentC.color;
										tagData.color = parentC.color;
									}
									if(parentC.face){
										newTg.face = parentC.face;
										tagData.face = parentC.face;
									}
									if(parentC.size){  // this check was necessary on IE
										newTg.size = parentC.size;
										tagData.size = parentC.size;
									}
								}
								if(parentC.className){
									newTg.className = parentC.className;
									tagData.className = parentC.className;
								}

								// Now move end node and every sibling
								// after it over into the new tag.
								if(endNode){
									nodeToMove = endNode;
									while(nodeToMove){
										tNode = nodeToMove.nextSibling;
										newTg.appendChild(nodeToMove);
										nodeToMove = tNode;
									}
								}
								if(newTg.tagName == parentC.tagName){
									breaker = doc.createElement(&quot;span&quot;);
									breaker.className = &quot;ieFormatBreakerSpan&quot;;
									domConstruct.place(breaker, parentC, &quot;after&quot;);
									domConstruct.place(newTg, breaker, &quot;after&quot;);
								}else{
									domConstruct.place(newTg, parentC, &quot;after&quot;);
								}
								startNode = parentC;
								endNode = newTg;
								parentC = parentC.parentNode;
							}

							// Lastly, move the split out all the split tags
							// to the new block as they should now be split properly.
							if(endNode){
								nodeToMove = endNode;
								if(nodeToMove.nodeType === 1 || (nodeToMove.nodeType === 3 &amp;&amp; nodeToMove.nodeValue)){
									// Non-blank text and non-text nodes need to clear out that blank space
									// before moving the contents.
									newblock.innerHTML = &quot;&quot;;
								}
								while(nodeToMove){
									tNode = nodeToMove.nextSibling;
									newblock.appendChild(nodeToMove);
									nodeToMove = tNode;
								}
							}

							// We had intermediate tags, we have to now recreate them inbetween the split
							// and restore what styles, classnames, etc, we can.
							var newrange;
							if(tagList.length){
								tagData = tagList.pop();
								var newContTag = doc.createElement(tagData.tagName);
								if(tagData.cssText &amp;&amp; newContTag.style){
									newContTag.style.cssText = tagData.cssText;
								}
								if(tagData.className){
									newContTag.className = tagData.className;
								}
								if(tagData.tagName === &quot;FONT&quot;){
									if(tagData.color){
										newContTag.color = tagData.color;
									}
									if(tagData.face){
										newContTag.face = tagData.face;
									}
									if(tagData.size){
										newContTag.size = tagData.size;
									}
								}
								domConstruct.place(newContTag, newblock, &quot;before&quot;);
								while(tagList.length){
									tagData = tagList.pop();
									var newTgNode = doc.createElement(tagData.tagName);
									if(tagData.cssText &amp;&amp; newTgNode.style){
										newTgNode.style.cssText = tagData.cssText;
									}
									if(tagData.className){
										newTgNode.className = tagData.className;
									}
									if(tagData.tagName === &quot;FONT&quot;){
										if(tagData.color){
											newTgNode.color = tagData.color;
										}
										if(tagData.face){
											newTgNode.face = tagData.face;
										}
										if(tagData.size){
											newTgNode.size = tagData.size;
										}
									}
									newContTag.appendChild(newTgNode);
									newContTag = newTgNode;
								}

								// Okay, everything is theoretically split apart and removed from the content
								// so insert the dummy text to select, select it, then
								// clear to position cursor.
								sNode = doc.createTextNode(&quot;.&quot;);
								breaker.appendChild(sNode);
								newContTag.appendChild(sNode);
								newrange = rangeapi.create(this.window);
								newrange.setStart(sNode, 0);
								newrange.setEnd(sNode, sNode.length);
								selection.removeAllRanges();
								selection.addRange(newrange);
								this.selection.collapse(false);
								sNode.parentNode.innerHTML = &quot;&quot;;
							}else{
								// No extra tags, so we have to insert a breaker point and rely
								// on filters to remove it later.
								breaker = doc.createElement(&quot;span&quot;);
								breaker.className = &quot;ieFormatBreakerSpan&quot;;
								sNode = doc.createTextNode(&quot;.&quot;);
								breaker.appendChild(sNode);
								domConstruct.place(breaker, newblock, &quot;before&quot;);
								newrange = rangeapi.create(this.window);
								newrange.setStart(sNode, 0);
								newrange.setEnd(sNode, sNode.length);
								selection.removeAllRanges();
								selection.addRange(newrange);
								this.selection.collapse(false);
								sNode.parentNode.innerHTML = &quot;&quot;;
							}
							if(!newblock.firstChild){
								// Empty, we don&#x27;t need it.  Split was at end or similar
								// So, remove it.
								domConstruct.destroy(newblock);
							}
							return true;
						}
					}
					return false;
				}else{
					range = selection.getRangeAt(0);
					rs = range.startContainer;
					if(rs &amp;&amp; rs.nodeType === 3){
						// Text node, we have to split it.
						var offset = range.startOffset;
						if(rs.length &lt; offset){
							//We are not splitting the right node, try to locate the correct one
							ret = this._adjustNodeAndOffset(rs, offset);
							rs = ret.node;
							offset = ret.offset;
						}
						txt = rs.nodeValue;
						startNode = doc.createTextNode(txt.substring(0, offset));
						var endText = txt.substring(offset);
						if(endText !== &quot;&quot;){
							endNode = doc.createTextNode(txt.substring(offset));
						}
						// Create a space, we&#x27;ll select and bold it, so
						// the whole word doesn&#x27;t get bolded
						breaker = doc.createElement(&quot;span&quot;);
						sNode = doc.createTextNode(&quot;.&quot;);
						breaker.appendChild(sNode);
						if(startNode.length){
							domConstruct.place(startNode, rs, &quot;after&quot;);
						}else{
							startNode = rs;
						}
						domConstruct.place(breaker, startNode, &quot;after&quot;);
						if(endNode){
							domConstruct.place(endNode, breaker, &quot;after&quot;);
						}
						domConstruct.destroy(rs);
						var newrange = rangeapi.create(this.window);
						newrange.setStart(sNode, 0);
						newrange.setEnd(sNode, sNode.length);
						selection.removeAllRanges();
						selection.addRange(newrange);
						doc.execCommand(command);
						domConstruct.place(breaker.firstChild, breaker, &quot;before&quot;);
						domConstruct.destroy(breaker);
						newrange.setStart(sNode, 0);
						newrange.setEnd(sNode, sNode.length);
						selection.removeAllRanges();
						selection.addRange(newrange);
						this.selection.collapse(false);
						sNode.parentNode.innerHTML = &quot;&quot;;
						return true;
					}
				}
			}else{
				return false;
			}
		},

		_adaptIEList: function(command /*===== , argument =====*/){
			// summary:
			//		This function handles normalizing the IE list behavior as
			//		much as possible.
			// command:
			//		The list command to execute.
			// argument:
			//		Any additional argument.
			// tags:
			//		private
			var selection = rangeapi.getSelection(this.window);
			if(selection.isCollapsed){
				// In the case of no selection, let&#x27;s commonize the behavior and
				// make sure that it indents if needed.
				if(selection.rangeCount &amp;&amp; !this.queryCommandValue(command)){
					var range = selection.getRangeAt(0);
					var sc = range.startContainer;
					if(sc &amp;&amp; sc.nodeType == 3){
						// text node.  Lets see if there is a node before it that isn&#x27;t
						// some sort of breaker.
						if(!range.startOffset){
							// We&#x27;re at the beginning of a text area.  It may have been br split
							// Who knows?  In any event, we must create the list manually
							// or IE may shove too much into the list element.  It seems to
							// grab content before the text node too if it&#x27;s br split.
							// Why can&#x27;t IE work like everyone else?
							// This problem also happens on Edge.

							// Create a space, we&#x27;ll select and bold it, so
							// the whole word doesn&#x27;t get bolded
							var lType = &quot;ul&quot;;
							if(command === &quot;insertorderedlist&quot;){
								lType = &quot;ol&quot;;
							}
							var list = this.document.createElement(lType);
							var li = domConstruct.create(&quot;li&quot;, null, list);
							domConstruct.place(list, sc, &quot;before&quot;);
							// Move in the text node as part of the li.
							li.appendChild(sc);
							// We need a br after it or the enter key handler
							// sometimes throws errors.
							domConstruct.create(&quot;br&quot;, null, list, &quot;after&quot;);
							// Okay, now lets move our cursor to the beginning.
							var newrange = rangeapi.create(this.window);
							newrange.setStart(sc, 0);
							newrange.setEnd(sc, sc.length);
							selection.removeAllRanges();
							selection.addRange(newrange);
							this.selection.collapse(true);
							return true;
						}
					}
				}
			}
			return false;
		},

		_handleTextColorOrProperties: function(command, argument){
			// summary:
			//		This function handles applying text color as best it is
			//		able to do so when the selection is collapsed, making the
			//		behavior cross-browser consistent. It also handles the name
			//		and size for IE.
			// command:
			//		The command.
			// argument:
			//		Any additional arguments.
			// tags:
			//		private
			var selection = rangeapi.getSelection(this.window);
			var doc = this.document;
			var rs, ret, range, txt, startNode, endNode, breaker, sNode;
			argument = argument || null;
			if(command &amp;&amp; selection &amp;&amp; selection.isCollapsed){
				if(selection.rangeCount){
					range = selection.getRangeAt(0);
					rs = range.startContainer;
					if(rs &amp;&amp; rs.nodeType === 3){
						// Text node, we have to split it.
						var offset = range.startOffset;
						if(rs.length &lt; offset){
							//We are not splitting the right node, try to locate the correct one
							ret = this._adjustNodeAndOffset(rs, offset);
							rs = ret.node;
							offset = ret.offset;
						}
						txt = rs.nodeValue;
						startNode = doc.createTextNode(txt.substring(0, offset));
						var endText = txt.substring(offset);
						if(endText !== &quot;&quot;){
							endNode = doc.createTextNode(txt.substring(offset));
						}
						// Create a space, we&#x27;ll select and bold it, so
						// the whole word doesn&#x27;t get bolded
						breaker = doc.createElement(&quot;span&quot;);
						sNode = doc.createTextNode(&quot;.&quot;);
						breaker.appendChild(sNode);
						// Create a junk node to avoid it trying to style the breaker.
						// This will get destroyed later.
						var extraSpan = doc.createElement(&quot;span&quot;);
						breaker.appendChild(extraSpan);
						if(startNode.length){
							domConstruct.place(startNode, rs, &quot;after&quot;);
						}else{
							startNode = rs;
						}
						domConstruct.place(breaker, startNode, &quot;after&quot;);
						if(endNode){
							domConstruct.place(endNode, breaker, &quot;after&quot;);
						}
						domConstruct.destroy(rs);
						var newrange = rangeapi.create(this.window);
						newrange.setStart(sNode, 0);
						newrange.setEnd(sNode, sNode.length);
						selection.removeAllRanges();
						selection.addRange(newrange);
						if(has(&quot;webkit&quot;)){
							// WebKit is frustrating with positioning the cursor.
							// It stinks to have a selected space, but there really
							// isn&#x27;t much choice here.
							var style = &quot;color&quot;;
							if(command === &quot;hilitecolor&quot; || command === &quot;backcolor&quot;){
								style = &quot;backgroundColor&quot;;
							}
							domStyle.set(breaker, style, argument);
							this.selection.remove();
							domConstruct.destroy(extraSpan);
							breaker.innerHTML = &quot;&amp;#160;&quot;;	// &amp;nbsp;
							this.selection.selectElement(breaker);
							this.focus();
						}else{
							this.execCommand(command, argument);
							domConstruct.place(breaker.firstChild, breaker, &quot;before&quot;);
							domConstruct.destroy(breaker);
							newrange.setStart(sNode, 0);
							newrange.setEnd(sNode, sNode.length);
							selection.removeAllRanges();
							selection.addRange(newrange);
							this.selection.collapse(false);
							sNode.parentNode.removeChild(sNode);
						}
						return true;
					}
				}
			}
			return false;
		},

		_adjustNodeAndOffset: function(/*DomNode*/node, /*Int*/offset){
			// summary:
			//		In the case there are multiple text nodes in a row the offset may not be within the node.
			//		If the offset is larger than the node length, it will attempt to find
			//		the next text sibling until it locates the text node in which the offset refers to
			// node:
			//		The node to check.
			// offset:
			//		The position to find within the text node
			// tags:
			//		private.
			while(node.length &lt; offset &amp;&amp; node.nextSibling &amp;&amp; node.nextSibling.nodeType === 3){
				//Adjust the offset and node in the case of multiple text nodes in a row
				offset = offset - node.length;
				node = node.nextSibling;
			}
			return {&quot;node&quot;: node, &quot;offset&quot;: offset};
		},

		_tagNamesForCommand: function(command){
			// summary:
			//		Function to return the tab names that are associated
			//		with a particular style.
			// command: String
			//		The command to return tags for.
			// tags:
			//		private
			if(command === &quot;bold&quot;){
				return [&quot;b&quot;, &quot;strong&quot;];
			}else if(command === &quot;italic&quot;){
				return [&quot;i&quot;, &quot;em&quot;];
			}else if(command === &quot;strikethrough&quot;){
				return [&quot;s&quot;, &quot;strike&quot;];
			}else if(command === &quot;superscript&quot;){
				return [&quot;sup&quot;];
			}else if(command === &quot;subscript&quot;){
				return [&quot;sub&quot;];
			}else if(command === &quot;underline&quot;){
				return [&quot;u&quot;];
			}
			return [];
		},

		_stripBreakerNodes: function(/*DOMNode*/ node){
			// summary:
			//		Function for stripping out the breaker spans inserted by the formatting command.
			//		Registered as a filter for IE, handles the breaker spans needed to fix up
			//		How bold/italic/etc, work when selection is collapsed (single cursor).
			if(!this.isLoaded){
				return;
			} // this method requires init to be complete
			query(&quot;.ieFormatBreakerSpan&quot;, node).forEach(function(b){
				while(b.firstChild){
					domConstruct.place(b.firstChild, b, &quot;before&quot;);
				}
				domConstruct.destroy(b);
			});
			return node;
		},

		_stripTrailingEmptyNodes: function(/*DOMNode*/ node){
			// summary:
			//		Function for stripping trailing nodes without any text, excluding trailing nodes
			//		like &lt;img&gt; or &lt;div&gt;&lt;img&gt;&lt;/div&gt;, even though they don&#x27;t have text either.

			function isEmpty(node){
				// If not for old IE we could check for Element children by node.firstElementChild
				return (/^(p|div|br)$/i.test(node.nodeName) &amp;&amp; node.children.length == 0 &amp;&amp;
					/^[\s\xA0]*$/.test(node.textContent || node.innerText || &quot;&quot;)) ||
					(node.nodeType === 3/*text*/ &amp;&amp; /^[\s\xA0]*$/.test(node.nodeValue));
			}
			while(node.lastChild &amp;&amp; isEmpty(node.lastChild)){
				domConstruct.destroy(node.lastChild);
			}

			return node;
		},

		// Needed to support ToggleDir plugin.  Intentionally not inside if(has(&quot;dojo-bidi&quot;)) block
		// so that (for backwards compatibility) ToggleDir plugin works even when has(&quot;dojo-bidi&quot;) is falsy.
		_setTextDirAttr: function(/*String*/ value){
			// summary:
			//		Sets textDir attribute.  Sets direction of editNode accordingly.
			this._set(&quot;textDir&quot;, value);
			this.onLoadDeferred.then(lang.hitch(this, function(){
				this.editNode.dir = value;
			}));
		}
	});

	return RichText;
});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
