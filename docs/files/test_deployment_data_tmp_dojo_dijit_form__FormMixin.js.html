<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>test\deployment\data\tmp\dojo\dijit\form\_FormMixin.js - YUI ArcGIS</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="YUI ArcGIS" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Main.html">Main</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: test\deployment\data\tmp\dojo\dijit\form\_FormMixin.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
define(&quot;dijit/form/_FormMixin&quot;, [
	&quot;dojo/_base/array&quot;, // array.every array.filter array.forEach array.indexOf array.map
	&quot;dojo/_base/declare&quot;, // declare
	&quot;dojo/_base/kernel&quot;, // kernel.deprecated
	&quot;dojo/_base/lang&quot;, // lang.hitch lang.isArray
	&quot;dojo/on&quot;,
	&quot;dojo/window&quot; // winUtils.scrollIntoView
], function(array, declare, kernel, lang, on, winUtils){

	// module:
	//		dijit/form/_FormMixin

	return declare(&quot;dijit.form._FormMixin&quot;, null, {
		// summary:
		//		Mixin for containers of form widgets (i.e. widgets that represent a single value
		//		and can be children of a &#x60;&lt;form&gt;&#x60; node or &#x60;dijit/form/Form&#x60; widget)
		// description:
		//		Can extract all the form widgets
		//		values and combine them into a single javascript object, or alternately
		//		take such an object and set the values for all the contained
		//		form widgets

	/*=====
		// value: Object
		//		Name/value hash for each child widget with a name and value.
		//		Child widgets without names are not part of the hash.
		//
		//		If there are multiple child widgets w/the same name, value is an array,
		//		unless they are radio buttons in which case value is a scalar (since only
		//		one radio button can be checked at a time).
		//
		//		If a child widget&#x27;s name is a dot separated list (like a.b.c.d), it&#x27;s a nested structure.
		//
		//		Example:
		//	|	{ name: &quot;John Smith&quot;, interests: [&quot;sports&quot;, &quot;movies&quot;] }
	=====*/

		// state: [readonly] String
		//		Will be &quot;Error&quot; if one or more of the child widgets has an invalid value,
		//		&quot;Incomplete&quot; if not all of the required child widgets are filled in.  Otherwise, &quot;&quot;,
		//		which indicates that the form is ready to be submitted.
		state: &quot;&quot;,

		// TODO:
		//	* Repeater
		//	* better handling for arrays.  Often form elements have names with [] like
		//	* people[3].sex (for a list of people [{name: Bill, sex: M}, ...])


		_getDescendantFormWidgets: function(/*dijit/_WidgetBase[]?*/ children){
			// summary:
			//		Returns all form widget descendants, searching through non-form child widgets like BorderContainer
			var res = [];
			array.forEach(children || this.getChildren(), function(child){
				if(&quot;value&quot; in child){
					res.push(child);
				}else{
					res = res.concat(this._getDescendantFormWidgets(child.getChildren()));
				}
			}, this);
			return res;
		},

		reset: function(){
			array.forEach(this._getDescendantFormWidgets(), function(widget){
				if(widget.reset){
					widget.reset();
				}
			});
		},

		validate: function(){
			// summary:
			//		returns if the form is valid - same as isValid - but
			//		provides a few additional (ui-specific) features:
			//
			//		1. it will highlight any sub-widgets that are not valid
			//		2. it will call focus() on the first invalid sub-widget
			var didFocus = false;
			return array.every(array.map(this._getDescendantFormWidgets(), function(widget){
				// Need to set this so that &quot;required&quot; widgets get their
				// state set.
				widget._hasBeenBlurred = true;
				var valid = widget.disabled || !widget.validate || widget.validate();
				if(!valid &amp;&amp; !didFocus){
					// Set focus of the first non-valid widget
					winUtils.scrollIntoView(widget.containerNode || widget.domNode);
					widget.focus();
					didFocus = true;
				}
				return valid;
			}), function(item){ return item; });
		},

		setValues: function(val){
			kernel.deprecated(this.declaredClass+&quot;::setValues() is deprecated. Use set(&#x27;value&#x27;, val) instead.&quot;, &quot;&quot;, &quot;2.0&quot;);
			return this.set(&#x27;value&#x27;, val);
		},
		_setValueAttr: function(/*Object*/ obj){
			// summary:
			//		Fill in form values from according to an Object (in the format returned by get(&#x27;value&#x27;))

			// generate map from name --&gt; [list of widgets with that name]
			var map = { };
			array.forEach(this._getDescendantFormWidgets(), function(widget){
				if(!widget.name){ return; }
				var entry = map[widget.name] || (map[widget.name] = [] );
				entry.push(widget);
			});

			for(var name in map){
				if(!map.hasOwnProperty(name)){
					continue;
				}
				var widgets = map[name],						// array of widgets w/this name
					values = lang.getObject(name, false, obj);	// list of values for those widgets

				if(values === undefined){
					continue;
				}
				values = [].concat(values);
				if(typeof widgets[0].checked == &#x27;boolean&#x27;){
					// for checkbox/radio, values is a list of which widgets should be checked
					array.forEach(widgets, function(w){
						w.set(&#x27;value&#x27;, array.indexOf(values, w._get(&#x27;value&#x27;)) != -1);
					});
				}else if(widgets[0].multiple){
					// it takes an array (e.g. multi-select)
					widgets[0].set(&#x27;value&#x27;, values);
				}else{
					// otherwise, values is a list of values to be assigned sequentially to each widget
					array.forEach(widgets, function(w, i){
						w.set(&#x27;value&#x27;, values[i]);
					});
				}
			}

			/***
			 *	TODO: code for plain input boxes (this shouldn&#x27;t run for inputs that are part of widgets)

			array.forEach(this.containerNode.elements, function(element){
				if(element.name == &#x27;&#x27;){return};	// like &quot;continue&quot;
				var namePath = element.name.split(&quot;.&quot;);
				var myObj=obj;
				var name=namePath[namePath.length-1];
				for(var j=1,len2=namePath.length;j&lt;len2;++j){
					var p=namePath[j - 1];
					// repeater support block
					var nameA=p.split(&quot;[&quot;);
					if(nameA.length &gt; 1){
						if(typeof(myObj[nameA[0]]) == &quot;undefined&quot;){
							myObj[nameA[0]]=[ ];
						} // if

						nameIndex=parseInt(nameA[1]);
						if(typeof(myObj[nameA[0]][nameIndex]) == &quot;undefined&quot;){
							myObj[nameA[0]][nameIndex] = { };
						}
						myObj=myObj[nameA[0]][nameIndex];
						continue;
					} // repeater support ends

					if(typeof(myObj[p]) == &quot;undefined&quot;){
						myObj=undefined;
						break;
					};
					myObj=myObj[p];
				}

				if(typeof(myObj) == &quot;undefined&quot;){
					return;		// like &quot;continue&quot;
				}
				if(typeof(myObj[name]) == &quot;undefined&quot; &amp;&amp; this.ignoreNullValues){
					return;		// like &quot;continue&quot;
				}

				// TODO: widget values (just call set(&#x27;value&#x27;, ...) on the widget)

				// TODO: maybe should call dojo.getNodeProp() instead
				switch(element.type){
					case &quot;checkbox&quot;:
						element.checked = (name in myObj) &amp;&amp;
							array.some(myObj[name], function(val){ return val == element.value; });
						break;
					case &quot;radio&quot;:
						element.checked = (name in myObj) &amp;&amp; myObj[name] == element.value;
						break;
					case &quot;select-multiple&quot;:
						element.selectedIndex=-1;
						array.forEach(element.options, function(option){
							option.selected = array.some(myObj[name], function(val){ return option.value == val; });
						});
						break;
					case &quot;select-one&quot;:
						element.selectedIndex=&quot;0&quot;;
						array.forEach(element.options, function(option){
							option.selected = option.value == myObj[name];
						});
						break;
					case &quot;hidden&quot;:
					case &quot;text&quot;:
					case &quot;textarea&quot;:
					case &quot;password&quot;:
						element.value = myObj[name] || &quot;&quot;;
						break;
				}
			});
			*/

			// Note: no need to call this._set(&quot;value&quot;, ...) as the child updates will trigger onChange events
			// which I am monitoring.
		},

		getValues: function(){
			kernel.deprecated(this.declaredClass+&quot;::getValues() is deprecated. Use get(&#x27;value&#x27;) instead.&quot;, &quot;&quot;, &quot;2.0&quot;);
			return this.get(&#x27;value&#x27;);
		},
		_getValueAttr: function(){
			// summary:
			//		Returns Object representing form values.   See description of &#x60;value&#x60; for details.
			// description:

			// The value is updated into this.value every time a child has an onChange event,
			// so in the common case this function could just return this.value.   However,
			// that wouldn&#x27;t work when:
			//
			// 1. User presses return key to submit a form.  That doesn&#x27;t fire an onchange event,
			// and even if it did it would come too late due to the defer(...) in _handleOnChange()
			//
			// 2. app for some reason calls this.get(&quot;value&quot;) while the user is typing into a
			// form field.   Not sure if that case needs to be supported or not.

			// get widget values
			var obj = { };
			array.forEach(this._getDescendantFormWidgets(), function(widget){
				var name = widget.name;
				if(!name || widget.disabled){ return; }

				// Single value widget (checkbox, radio, or plain &lt;input&gt; type widget)
				var value = widget.get(&#x27;value&#x27;);

				// Store widget&#x27;s value(s) as a scalar, except for checkboxes which are automatically arrays
				if(typeof widget.checked == &#x27;boolean&#x27;){
					if(/Radio/.test(widget.declaredClass)){
						// radio button
						if(value !== false){
							lang.setObject(name, value, obj);
						}else{
							// give radio widgets a default of null
							value = lang.getObject(name, false, obj);
							if(value === undefined){
								lang.setObject(name, null, obj);
							}
						}
					}else{
						// checkbox/toggle button
						var ary=lang.getObject(name, false, obj);
						if(!ary){
							ary=[];
							lang.setObject(name, ary, obj);
						}
						if(value !== false){
							ary.push(value);
						}
					}
				}else{
					var prev=lang.getObject(name, false, obj);
					if(typeof prev != &quot;undefined&quot;){
						if(lang.isArray(prev)){
							prev.push(value);
						}else{
							lang.setObject(name, [prev, value], obj);
						}
					}else{
						// unique name
						lang.setObject(name, value, obj);
					}
				}
			});

			/***
			 * code for plain input boxes (see also domForm.formToObject, can we use that instead of this code?
			 * but it doesn&#x27;t understand [] notation, presumably)
			var obj = { };
			array.forEach(this.containerNode.elements, function(elm){
				if(!elm.name)	{
					return;		// like &quot;continue&quot;
				}
				var namePath = elm.name.split(&quot;.&quot;);
				var myObj=obj;
				var name=namePath[namePath.length-1];
				for(var j=1,len2=namePath.length;j&lt;len2;++j){
					var nameIndex = null;
					var p=namePath[j - 1];
					var nameA=p.split(&quot;[&quot;);
					if(nameA.length &gt; 1){
						if(typeof(myObj[nameA[0]]) == &quot;undefined&quot;){
							myObj[nameA[0]]=[ ];
						} // if
						nameIndex=parseInt(nameA[1]);
						if(typeof(myObj[nameA[0]][nameIndex]) == &quot;undefined&quot;){
							myObj[nameA[0]][nameIndex] = { };
						}
					}else if(typeof(myObj[nameA[0]]) == &quot;undefined&quot;){
						myObj[nameA[0]] = { }
					} // if

					if(nameA.length == 1){
						myObj=myObj[nameA[0]];
					}else{
						myObj=myObj[nameA[0]][nameIndex];
					} // if
				} // for

				if((elm.type != &quot;select-multiple&quot; &amp;&amp; elm.type != &quot;checkbox&quot; &amp;&amp; elm.type != &quot;radio&quot;) || (elm.type == &quot;radio&quot; &amp;&amp; elm.checked)){
					if(name == name.split(&quot;[&quot;)[0]){
						myObj[name]=elm.value;
					}else{
						// can not set value when there is no name
					}
				}else if(elm.type == &quot;checkbox&quot; &amp;&amp; elm.checked){
					if(typeof(myObj[name]) == &#x27;undefined&#x27;){
						myObj[name]=[ ];
					}
					myObj[name].push(elm.value);
				}else if(elm.type == &quot;select-multiple&quot;){
					if(typeof(myObj[name]) == &#x27;undefined&#x27;){
						myObj[name]=[ ];
					}
					for(var jdx=0,len3=elm.options.length; jdx&lt;len3; ++jdx){
						if(elm.options[jdx].selected){
							myObj[name].push(elm.options[jdx].value);
						}
					}
				} // if
				name=undefined;
			}); // forEach
			***/
			return obj;
		},

		isValid: function(){
			// summary:
			//		Returns true if all of the widgets are valid.
			//		Deprecated, will be removed in 2.0.  Use get(&quot;state&quot;) instead.

			return this.state == &quot;&quot;;
		},

		onValidStateChange: function(/*Boolean*/ /*===== isValid =====*/){
			// summary:
			//		Stub function to connect to if you want to do something
			//		(like disable/enable a submit button) when the valid
			//		state changes on the form as a whole.
			//
			//		Deprecated.  Will be removed in 2.0.  Use watch(&quot;state&quot;, ...) instead.
		},

		_getState: function(){
			// summary:
			//		Compute what this.state should be based on state of children
			var states = array.map(this._descendants, function(w){
				return w.get(&quot;state&quot;) || &quot;&quot;;
			});

			return array.indexOf(states, &quot;Error&quot;) &gt;= 0 ? &quot;Error&quot; :
				array.indexOf(states, &quot;Incomplete&quot;) &gt;= 0 ? &quot;Incomplete&quot; : &quot;&quot;;
		},

		disconnectChildren: function(){
			// summary:
			//		Deprecated method.   Applications no longer need to call this.   Remove for 2.0.
		},

		connectChildren: function(/*Boolean*/ inStartup){
			// summary:
			//		You can call this function directly, ex. in the event that you
			//		programmatically add a widget to the form *after* the form has been
			//		initialized.

			// TODO: rename for 2.0

			this._descendants = this._getDescendantFormWidgets();

			// To get notifications from children they need to be started.   Children didn&#x27;t used to need to be started,
			// so for back-compat, start them here
			array.forEach(this._descendants, function(child){
				if(!child._started){ child.startup(); }
			});

			if(!inStartup){
				this._onChildChange();
			}
		},

		_onChildChange: function(/*String*/ attr){
			// summary:
			//		Called when child&#x27;s value or disabled state changes

			// The unit tests expect state update to be synchronous, so update it immediately.
			if(!attr || attr == &quot;state&quot; || attr == &quot;disabled&quot;){
				this._set(&quot;state&quot;, this._getState());
			}

			// Use defer() to collapse value changes in multiple children into a single
			// update to my value.   Multiple updates will occur on:
			//	1. Form.set()
			//	2. Form.reset()
			//	3. user selecting a radio button (which will de-select another radio button,
			//		 causing two onChange events)
			if(!attr || attr == &quot;value&quot; || attr == &quot;disabled&quot; || attr == &quot;checked&quot;){
				if(this._onChangeDelayTimer){
					this._onChangeDelayTimer.remove();
				}
				this._onChangeDelayTimer = this.defer(function(){
					delete this._onChangeDelayTimer;
					this._set(&quot;value&quot;, this.get(&quot;value&quot;));
				}, 10);
			}
		},

		startup: function(){
			this.inherited(arguments);

			// Set initial this.value and this.state.   Don&#x27;t emit watch() notifications.
			this._descendants = this._getDescendantFormWidgets();
			this.value = this.get(&quot;value&quot;);
			this.state = this._getState();

			// Initialize value and valid/invalid state tracking.
			var self = this;
			this.own(
				on(
					this.containerNode,
					&quot;attrmodified-state, attrmodified-disabled, attrmodified-value, attrmodified-checked&quot;,
					function(evt){
						if(evt.target == self.domNode){
							return;	// ignore events that I fire on myself because my children changed
						}
						self._onChildChange(evt.type.replace(&quot;attrmodified-&quot;, &quot;&quot;));
					}
				)
			);

			// Make state change call onValidStateChange(), will be removed in 2.0
			this.watch(&quot;state&quot;, function(attr, oldVal, newVal){ this.onValidStateChange(newVal == &quot;&quot;); });
		},

		destroy: function(){
			this.inherited(arguments);
		}

	});
});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
