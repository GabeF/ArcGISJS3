<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>test\deployment\data\tmp\dojo\dojox\date\timezone.js - YUI ArcGIS</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="YUI ArcGIS" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Main.html">Main</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: test\deployment\data\tmp\dojo\dojox\date\timezone.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/******************************************************************************
 * Dojo port of fleegix date plugin from
 *
 *   http://js.fleegix.org/plugins/date/date
 *
 * contributed to Dojo under CLA, with thanks to Matthew Eernisse (mde@fleegix.org)
 * and Open Source Applications Foundation
 *
 * Credits: Ideas included from incomplete JS implementation of Olson
 * parser, &quot;XMLDate&quot; by Philippe Goetz (philippe.goetz@wanadoo.fr)
 *****************************************************************************/

define(&quot;dojox/date/timezone&quot;, [
    &quot;dojo/_base/array&quot;,
    &quot;dojo/_base/config&quot;,
    &quot;dojo/_base/declare&quot;,
    &quot;dojo/_base/kernel&quot;,
    &quot;dojo/_base/lang&quot;,
    &quot;dojo/date&quot;,
    &quot;dojo/date/locale&quot;,
    &quot;dojo/request&quot;,
    &quot;dojo/request/handlers&quot;
],
function(arrayUtil, config, declare, kernel, lang, dateUtil, localeUtil, request, handlers){
	kernel.experimental(&quot;dojox.date.timezone&quot;);

	var _zoneFiles = [ &quot;africa&quot;, &quot;antarctica&quot;, &quot;asia&quot;, &quot;australasia&quot;, &quot;backward&quot;,
					&quot;etcetera&quot;, &quot;europe&quot;, &quot;northamerica&quot;, &quot;pacificnew&quot;,
					&quot;southamerica&quot; ];

	// Our mins an maxes for years that we care about
	var _minYear = 1835,
		_maxYear = 2038;

	var _loadedZones = {},
		_zones = {},
		_loadedRanges = {},
		_rules = {};

	// loadingScheme: String
	//		One of &quot;preloadAll&quot;, &quot;lazyLoad&quot; (Defaults &quot;preloadAll&quot;)
	var loadingScheme = config.timezoneLoadingScheme || &quot;preloadAll&quot;;

	// defaultZoneFile: String or String[]
	//		The default file (or files) to load on startup - other files will
	//		be lazily-loaded on-demand
	var defaultZoneFile = config.defaultZoneFile ||
					((loadingScheme == &quot;preloadAll&quot;) ? _zoneFiles : &quot;northamerica&quot;);

	// Set our olson_zoneinfo content handler
	handlers.register(&quot;olson_zoneinfo&quot;, function(response) {
		var text = response.text,
			s = &quot;&quot;,
			lines = text.split(&quot;\n&quot;),
			arr = [],
			chunk = &quot;&quot;,
			zone = null,
			rule = null,
			ret = {zones: {}, rules: {}};

		for(var i = 0; i &lt; lines.length; i++){
			var l = lines[i];
			if(l.match(/^\s/)){
				l = &quot;Zone &quot; + zone + l;
			}
			l = l.split(&quot;#&quot;)[0];
			if(l.length &gt; 3){
				arr = l.split(/\s+/);
				chunk = arr.shift();
				switch(chunk){
					case &#x27;Zone&#x27;:
						zone = arr.shift();
						if(arr[0]){
							// Handle extra commas in the middle of a zone
							if(!ret.zones[zone]){ ret.zones[zone] = []; }
							ret.zones[zone].push(arr);
						}
						break;
					case &#x27;Rule&#x27;:
						rule = arr.shift();
						if(!ret.rules[rule]){ ret.rules[rule] = []; }
						ret.rules[rule].push(arr);
						break;
					case &#x27;Link&#x27;:
						// No zones for these should already exist
						if(ret.zones[arr[1]]){
						  throw new Error(&#x27;Error with Link &#x27; + arr[1]);
						}
						// Create the link
						ret.zones[arr[1]] = arr[0];
						break;
					case &#x27;Leap&#x27;:
						break;
					default:
						// Fail silently
						break;
				}
			}
		}
		return ret; // Object
	});

	function loadZoneData(/* Object */ data){
		// summary:
		//		Loads the given data object into the zone database
		// data: Object
		//		The data to load - contains &quot;zones&quot; and &quot;rules&quot; parameters
		data = data || {};
		_zones = lang.mixin(_zones, data.zones||{});
		_rules = lang.mixin(_rules, data.rules||{});
	}

	function loadZoneFile(/* String */ fileName){
		// summary:
		//		Loads the given URL of the Olson zone information into the
		//		zone database
		//
		// fileName: String
		//		The zoneinfo file name to load

		// TODO: Maybe behave similar to requireLocalization - rather than
		//		Using request.get?
		_loadedZones[fileName] = true;
		request.get(require.toUrl((config.timezoneFileBasePath || &quot;dojox/date/zoneinfo&quot;) + &quot;/&quot; + fileName), {
			handleAs: &quot;olson_zoneinfo&quot;,
			sync: true
		}).then(loadZoneData, function(e){
			console.error(&quot;Error loading zone file:&quot;, e);
			throw e;
		});
	}

	var monthMap = { &#x27;jan&#x27;: 0, &#x27;feb&#x27;: 1, &#x27;mar&#x27;: 2, &#x27;apr&#x27;: 3,&#x27;may&#x27;: 4, &#x27;jun&#x27;: 5,
				&#x27;jul&#x27;: 6, &#x27;aug&#x27;: 7, &#x27;sep&#x27;: 8, &#x27;oct&#x27;: 9, &#x27;nov&#x27;: 10, &#x27;dec&#x27;: 11 },
		dayMap = {&#x27;sun&#x27;: 0, &#x27;mon&#x27;: 1, &#x27;tue&#x27;: 2, &#x27;wed&#x27;: 3, &#x27;thu&#x27;: 4,
				&#x27;fri&#x27;: 5, &#x27;sat&#x27;: 6 },
		regionMap = {&#x27;EST&#x27;: &quot;northamerica&quot;, &#x27;MST&#x27;: &quot;northamerica&quot;,
					&#x27;HST&#x27;: &quot;northamerica&quot;, &#x27;EST5EDT&#x27;: &quot;northamerica&quot;,
					&#x27;CST6CDT&#x27;: &quot;northamerica&quot;, &#x27;MST7MDT&#x27;: &quot;northamerica&quot;,
					&#x27;PST8PDT&#x27;: &quot;northamerica&quot;, &#x27;America&#x27;: &quot;northamerica&quot;,
					&#x27;Pacific&#x27;: &quot;australasia&quot;, &#x27;Atlantic&#x27;: &quot;europe&quot;,
					&#x27;Africa&#x27;: &quot;africa&quot;, &#x27;Indian&#x27;: &quot;africa&quot;,
					&#x27;Antarctica&#x27;: &quot;antarctica&quot;, &#x27;Asia&#x27;: &quot;asia&quot;,
					&#x27;Australia&#x27;: &quot;australasia&quot;, &#x27;Europe&#x27;: &quot;europe&quot;,
					&#x27;WET&#x27;: &quot;europe&quot;, &#x27;CET&#x27;: &quot;europe&quot;, &#x27;MET&#x27;: &quot;europe&quot;,
					&#x27;EET&#x27;: &quot;europe&quot;},
		regionExceptions = {&#x27;Pacific/Honolulu&#x27;:&quot;northamerica&quot;,
							&#x27;Atlantic/Bermuda&#x27;:&quot;northamerica&quot;,
							&#x27;Atlantic/Cape_Verde&#x27;:&quot;africa&quot;,
							&#x27;Atlantic/St_Helena&#x27;:&quot;africa&quot;,
							&#x27;Indian/Kerguelen&#x27;:&quot;antarctica&quot;,
							&#x27;Indian/Chagos&#x27;:&quot;asia&quot;,
							&#x27;Indian/Maldives&#x27;:&quot;asia&quot;,
							&#x27;Indian/Christmas&#x27;:&quot;australasia&quot;,
							&#x27;Indian/Cocos&#x27;:&quot;australasia&quot;,
							&#x27;America/Danmarkshavn&#x27;:&quot;europe&quot;,
							&#x27;America/Scoresbysund&#x27;:&quot;europe&quot;,
							&#x27;America/Godthab&#x27;:&quot;europe&quot;,
							&#x27;America/Thule&#x27;:&quot;europe&quot;,
							&#x27;Asia/Yekaterinburg&#x27;:&quot;europe&quot;,
							&#x27;Asia/Omsk&#x27;:&quot;europe&quot;,
							&#x27;Asia/Novosibirsk&#x27;:&quot;europe&quot;,
							&#x27;Asia/Krasnoyarsk&#x27;:&quot;europe&quot;,
							&#x27;Asia/Irkutsk&#x27;:&quot;europe&quot;,
							&#x27;Asia/Yakutsk&#x27;:&quot;europe&quot;,
							&#x27;Asia/Vladivostok&#x27;:&quot;europe&quot;,
							&#x27;Asia/Sakhalin&#x27;:&quot;europe&quot;,
							&#x27;Asia/Magadan&#x27;:&quot;europe&quot;,
							&#x27;Asia/Kamchatka&#x27;:&quot;europe&quot;,
							&#x27;Asia/Anadyr&#x27;:&quot;europe&quot;,
							&#x27;Africa/Ceuta&#x27;:&quot;europe&quot;,
							&#x27;America/Argentina/Buenos_Aires&#x27;:&quot;southamerica&quot;,
							&#x27;America/Argentina/Cordoba&#x27;:&quot;southamerica&quot;,
							&#x27;America/Argentina/Tucuman&#x27;:&quot;southamerica&quot;,
							&#x27;America/Argentina/La_Rioja&#x27;:&quot;southamerica&quot;,
							&#x27;America/Argentina/San_Juan&#x27;:&quot;southamerica&quot;,
							&#x27;America/Argentina/Jujuy&#x27;:&quot;southamerica&quot;,
							&#x27;America/Argentina/Catamarca&#x27;:&quot;southamerica&quot;,
							&#x27;America/Argentina/Mendoza&#x27;:&quot;southamerica&quot;,
							&#x27;America/Argentina/Rio_Gallegos&#x27;:&quot;southamerica&quot;,
							&#x27;America/Argentina/Ushuaia&#x27;:&quot;southamerica&quot;,
							&#x27;America/Aruba&#x27;:&quot;southamerica&quot;,
							&#x27;America/La_Paz&#x27;:&quot;southamerica&quot;,
							&#x27;America/Noronha&#x27;:&quot;southamerica&quot;,
							&#x27;America/Belem&#x27;:&quot;southamerica&quot;,
							&#x27;America/Fortaleza&#x27;:&quot;southamerica&quot;,
							&#x27;America/Recife&#x27;:&quot;southamerica&quot;,
							&#x27;America/Araguaina&#x27;:&quot;southamerica&quot;,
							&#x27;America/Maceio&#x27;:&quot;southamerica&quot;,
							&#x27;America/Bahia&#x27;:&quot;southamerica&quot;,
							&#x27;America/Sao_Paulo&#x27;:&quot;southamerica&quot;,
							&#x27;America/Campo_Grande&#x27;:&quot;southamerica&quot;,
							&#x27;America/Cuiaba&#x27;:&quot;southamerica&quot;,
							&#x27;America/Porto_Velho&#x27;:&quot;southamerica&quot;,
							&#x27;America/Boa_Vista&#x27;:&quot;southamerica&quot;,
							&#x27;America/Manaus&#x27;:&quot;southamerica&quot;,
							&#x27;America/Eirunepe&#x27;:&quot;southamerica&quot;,
							&#x27;America/Rio_Branco&#x27;:&quot;southamerica&quot;,
							&#x27;America/Santiago&#x27;:&quot;southamerica&quot;,
							&#x27;Pacific/Easter&#x27;:&quot;southamerica&quot;,
							&#x27;America/Bogota&#x27;:&quot;southamerica&quot;,
							&#x27;America/Curacao&#x27;:&quot;southamerica&quot;,
							&#x27;America/Guayaquil&#x27;:&quot;southamerica&quot;,
							&#x27;Pacific/Galapagos&#x27;:&quot;southamerica&quot;,
							&#x27;Atlantic/Stanley&#x27;:&quot;southamerica&quot;,
							&#x27;America/Cayenne&#x27;:&quot;southamerica&quot;,
							&#x27;America/Guyana&#x27;:&quot;southamerica&quot;,
							&#x27;America/Asuncion&#x27;:&quot;southamerica&quot;,
							&#x27;America/Lima&#x27;:&quot;southamerica&quot;,
							&#x27;Atlantic/South_Georgia&#x27;:&quot;southamerica&quot;,
							&#x27;America/Paramaribo&#x27;:&quot;southamerica&quot;,
							&#x27;America/Port_of_Spain&#x27;:&quot;southamerica&quot;,
							&#x27;America/Montevideo&#x27;:&quot;southamerica&quot;,
							&#x27;America/Caracas&#x27;:&quot;southamerica&quot;},
		abbrExceptions = { &#x27;US&#x27;: &quot;S&quot;, &#x27;Chatham&#x27;: &quot;S&quot;, &#x27;NZ&#x27;: &quot;S&quot;, &#x27;NT_YK&#x27;: &quot;S&quot;,
							&#x27;Edm&#x27;: &quot;S&quot;, &#x27;Salv&#x27;: &quot;S&quot;, &#x27;Canada&#x27;: &quot;S&quot;, &#x27;StJohns&#x27;: &quot;S&quot;,
							&#x27;TC&#x27;: &quot;S&quot;, &#x27;Guat&#x27;: &quot;S&quot;, &#x27;Mexico&#x27;: &quot;S&quot;, &#x27;Haiti&#x27;: &quot;S&quot;,
							&#x27;Barb&#x27;: &quot;S&quot;, &#x27;Belize&#x27;: &quot;S&quot;, &#x27;CR&#x27;: &quot;S&quot;, &#x27;Moncton&#x27;: &quot;S&quot;,
							&#x27;Swift&#x27;: &quot;S&quot;, &#x27;Hond&#x27;: &quot;S&quot;, &#x27;Thule&#x27;: &quot;S&quot;, &#x27;NZAQ&#x27;: &quot;S&quot;,
							&#x27;Zion&#x27;: &quot;S&quot;, &#x27;ROK&#x27;: &quot;S&quot;, &#x27;PRC&#x27;: &quot;S&quot;, &#x27;Taiwan&#x27;: &quot;S&quot;,
							&#x27;Ghana&#x27;: &quot;GMT&quot;, &#x27;SL&#x27;: &quot;WAT&quot;, &#x27;Chicago&#x27;: &quot;S&quot;,
							&#x27;Detroit&#x27;: &quot;S&quot;, &#x27;Vanc&#x27;: &quot;S&quot;, &#x27;Denver&#x27;: &quot;S&quot;,
							&#x27;Halifax&#x27;: &quot;S&quot;, &#x27;Cuba&#x27;: &quot;S&quot;, &#x27;Indianapolis&#x27;: &quot;S&quot;,
							&#x27;Starke&#x27;: &quot;S&quot;, &#x27;Marengo&#x27;: &quot;S&quot;, &#x27;Pike&#x27;: &quot;S&quot;,
							&#x27;Perry&#x27;: &quot;S&quot;, &#x27;Vincennes&#x27;: &quot;S&quot;, &#x27;Pulaski&#x27;: &quot;S&quot;,
							&#x27;Louisville&#x27;: &quot;S&quot;, &#x27;CA&#x27;: &quot;S&quot;, &#x27;Nic&#x27;: &quot;S&quot;,
							&#x27;Menominee&#x27;: &quot;S&quot;, &#x27;Mont&#x27;: &quot;S&quot;, &#x27;Bahamas&#x27;: &quot;S&quot;,
							&#x27;NYC&#x27;: &quot;S&quot;, &#x27;Regina&#x27;: &quot;S&quot;, &#x27;Resolute&#x27;: &quot;ES&quot;,
							&#x27;DR&#x27;: &quot;S&quot;, &#x27;Toronto&#x27;: &quot;S&quot;, &#x27;Winn&#x27;: &quot;S&quot; };

	function invalidTZError(t) {
		throw new Error(&#x27;Timezone &quot;&#x27; + t +
				&#x27;&quot; is either incorrect, or not loaded in the timezone registry.&#x27;);
	}

	function getRegionForTimezone(/* String */ tz) {
		// summary:
		//		Returns the Olson region for the given timezone
		var ret = regionExceptions[tz];
		if(!ret){
			var reg = tz.split(&#x27;/&#x27;)[0];
			ret = regionMap[reg];
			// If there&#x27;s nothing listed in the main regions for
			// this TZ, check the &#x27;backward&#x27; links
			if(!ret){
				var link = _zones[tz];
				if(typeof link == &#x27;string&#x27;){
					return getRegionForTimezone(link); // String
				}else{
					// Backward-compat file hasn&#x27;t loaded yet, try looking in there
					if (!_loadedZones.backward) {
						// This is for obvious legacy zones (e.g., Iceland) that
						// don&#x27;t even have a prefix like &quot;America/&quot; that look like
						// normal zones
						loadZoneFile(&quot;backward&quot;);
						return getRegionForTimezone(tz); // String
					}else{
						invalidTZError(tz);
					}
				}
			}
		}
		return ret; // String
	}

	function parseTimeString(/* String */ str) {
		// summary:
		//		Parses the given time string and returns it as an integer array
		var pat = /(\d+)(?::0*(\d*))?(?::0*(\d*))?([su])?$/;
		var hms = str.match(pat);
		if(!hms){
			return null;
		}
		hms[1] = parseInt(hms[1], 10);
		hms[2] = hms[2] ? parseInt(hms[2], 10) : 0;
		hms[3] = hms[3] ? parseInt(hms[3], 10) : 0;
		return hms; // int[]
	}

	function getUTCStamp(/* int */ y, /* int */ m, /* int */ d, /* int */ h,
						/* int */ mn, /* int */ s, /* int? */ off){
		// summary:
		//		Returns the UTC timestamp, adjusted by the given (optional) offset
		return Date.UTC(y, m, d, h, mn, s) + ((off||0) * 60 * 1000);
	}

	function getMonthNumber(/* String */ m){
		// summary:
		//		Returns the javascript month number for the given string
		return monthMap[m.substr(0, 3).toLowerCase()];
	}

	function getOffsetInMins(/* String */ str){
		// summary:
		//		Returns the offset value represented by the string, in minutes
		var off = parseTimeString(str);
		if(off === null){ return 0; }
		var adj = str.indexOf(&#x27;-&#x27;) === 0 ? -1 : 1;
		off = adj * (((off[1] * 60 + off[2]) *60 + off[3]) * 1000);
		return -off/60/1000;
	}

	function _getRuleStart(/* Rule */ rule, /* int */ year, /* int */ off){
		// summary:
		//		Returns a date that the rule begins matching in the given year.
		var month = getMonthNumber(rule[3]),
			day = rule[4],
			time = parseTimeString(rule[5]);
		if(time[4] == &quot;u&quot;){
			// We are UTC - so there is no offset to use
			off = 0;
		}

		var d, dtDay, incr;
		if(isNaN(day)){
			if(day.substr(0, 4) == &quot;last&quot;){
				// Last day of the month at the desired time of day
				day = dayMap[day.substr(4,3).toLowerCase()];
				d = new Date(getUTCStamp(year, month + 1, 1,
										time[1] - 24, time[2], time[3],
										off));
				dtDay = dateUtil.add(d, &quot;minute&quot;, -off).getUTCDay();
				// Set it to the final day of the correct weekday that month
				incr = (day &gt; dtDay) ? (day - dtDay - 7) : (day - dtDay);
				if(incr !== 0){
					d = dateUtil.add(d, &quot;hour&quot;, incr * 24);
				}
				return d;
			}else{
				day = dayMap[day.substr(0, 3).toLowerCase()];
				if(day != &quot;undefined&quot;){
					if(rule[4].substr(3, 2) == &#x27;&gt;=&#x27;){
						// The stated date of the month
						d = new Date(getUTCStamp(year, month, parseInt(rule[4].substr(5), 10),
									time[1], time[2], time[3], off));
						dtDay = dateUtil.add(d, &quot;minute&quot;, -off).getUTCDay();
						// Set to the first correct weekday after the stated date
						incr = (day &lt; dtDay) ? (day - dtDay + 7) : (day - dtDay);
						if(incr !== 0){
							d = dateUtil.add(d, &quot;hour&quot;, incr * 24);
						}
						return d;
					}else if(day.substr(3, 2) == &#x27;&lt;=&#x27;){
						// The stated date of the month
						d = new Date(getUTCStamp(year, month, parseInt(rule[4].substr(5), 10),
									time[1], time[2], time[3], off));
						dtDay = dateUtil.add(d, &quot;minute&quot;, -off).getUTCDay();
						// Set to first correct weekday before the stated date
						incr = (day &gt; dtDay) ? (day - dtDay - 7) : (day - dtDay);
						if(incr !== 0){
							d = dateUtil.add(d, &quot;hour&quot;, incr * 24);
						}
						return d;
					}
				}
			}
		}else{
			// Numeric date
			d = new Date(getUTCStamp(year, month, parseInt(day, 10),
						time[1], time[2], time[3], off));
			return d;
		}
		return null;
	}

	function _getRulesForYear(/* Zone */ zone, /* int */ year){
		var rules = [];
		arrayUtil.forEach(_rules[zone[1]]||[], function(r){
			// Clean up rules as needed
			for(var i = 0; i &lt; 2; i++){
				switch(r[i]){
					case &quot;min&quot;:
						r[i] = _minYear;
						break;
					case &quot;max&quot;:
						r[i] = _maxYear;
						break;
					case &quot;only&quot;:
						break;
					default:
						r[i] = parseInt(r[i], 10);
						if(isNaN(r[i])){
							throw new Error(&#x27;Invalid year found on rule&#x27;);
						}
						break;
				}
			}
			if(typeof r[6] == &quot;string&quot;){
				// Change our offset to be an integer
				r[6] = getOffsetInMins(r[6]);
			}

			// Quick-filter to grab all rules that match my year
			if((r[0] &lt;= year &amp;&amp; r[1] &gt;= year) || // Matches my y
				(r[0] == year &amp;&amp; r[1] == &quot;only&quot;)){ // Matches my only
				rules.push({r: r, d: _getRuleStart(r, year, zone[0])});
			}
		});
		return rules;
	}


	function _loadZoneRanges(/* String */ tz, /* Object[] */ zoneList) {
		// summary:
		//		Loads the zone ranges for the given timezone

		var zr = _loadedRanges[tz] = [];
		for(var i = 0; i &lt; zoneList.length; i++){
			var z = zoneList[i];
			var r = zr[i] = [];
			var prevZone = null;
			var prevRange = null;
			var prevRules = [];

			// Set up our zone offset to not be a string anymore
			if(typeof z[0] == &quot;string&quot;){
				z[0] = getOffsetInMins(z[0]);
			}

			if(i === 0){
				// The beginning of zoneinfo time - let&#x27;s not worry about
				// to-the-hour accuracy before Jan 1, 1835
				r[0] = Date.UTC(_minYear,0,1,0,0,0,0);
			}else{
				r[0] = zr[i - 1][1];
				prevZone = zoneList[i - 1];
				prevRange = zr[i - 1];
				prevRules = prevRange[2];
			}

			// Load the rules that will be going in to our zone
			var startYear = new Date(r[0]).getUTCFullYear();
			var endYear = z[3] ? parseInt(z[3], 10) : _maxYear;
			var rlz = [];
			var j;
			for(j = startYear; j &lt;= endYear; j++){
				rlz = rlz.concat(_getRulesForYear(z, j));
			}
			rlz.sort(function(a, b){
				return dateUtil.compare(a.d, b.d);
			});
			var rl;
			for(j = 0, rl; (rl = rlz[j]); j++){
				var prevRule = j &gt; 0 ? rlz[j - 1] : null;
				if(rl.r[5].indexOf(&quot;u&quot;) &lt; 0 &amp;&amp; rl.r[5].indexOf(&quot;s&quot;) &lt; 0){
					if(j === 0 &amp;&amp; i &gt; 0){
						if(prevRules.length){
							// We have a previous rule - so use it
							rl.d = dateUtil.add(rl.d, &quot;minute&quot;, prevRules[prevRules.length - 1].r[6]);
						}else if(dateUtil.compare(new Date(prevRange[1]), rl.d, &quot;date&quot;) === 0){
							// No previous rules - but our date is the same as the
							// previous zone ended on - so use that.
							rl.d = new Date(prevRange[1]);
						}else{
							rl.d = dateUtil.add(rl.d, &quot;minute&quot;, getOffsetInMins(prevZone[1]));
						}
					}else if(j &gt; 0){
						rl.d = dateUtil.add(rl.d, &quot;minute&quot;, prevRule.r[6]);
					}
				}
			}
			r[2] = rlz;

			if(!z[3]){
				// The end of zoneinfo time - we&#x27;ll cross this bridge when we
				// get close to Dec 31, 2038
				r[1] = Date.UTC(_maxYear,11,31,23,59,59,999);
			}else{
				var year = parseInt(z[3], 10),
					month = getMonthNumber(z[4]||&quot;Jan&quot;),
					day = parseInt(z[5]||&quot;1&quot;, 10),
					time = parseTimeString(z[6]||&quot;0&quot;);
				var utcStmp = r[1] = getUTCStamp(year, month, day,
									time[1], time[2], time[3],
									((time[4] == &quot;u&quot;) ? 0 : z[0]));
				if(isNaN(utcStmp)){
					utcStmp = r[1] = _getRuleStart([0,0,0,z[4],z[5],z[6]||&quot;0&quot;],
											year, ((time[4] == &quot;u&quot;) ? 0 : z[0])).getTime();
				}
				var matches = arrayUtil.filter(rlz, function(rl, idx){
					var o = idx &gt; 0 ? rlz[idx - 1].r[6] * 60 * 1000 : 0;
					return (rl.d.getTime() &lt; utcStmp + o);
				});
				if(time[4] != &quot;u&quot; &amp;&amp; time[4] != &quot;s&quot;){
					if(matches.length){
						r[1] += matches[matches.length - 1].r[6] * 60 * 1000;
					}else{
						r[1] += getOffsetInMins(z[1]) * 60 * 1000;
					}
				}
			}
		}
	}

	function getZoneInfo(/* String */ dt, /* String */ tz) {
		// summary:
		//		Returns the zone entry from the zoneinfo database for the given date
		//		and timezone
		var t = tz;
		var zoneList = _zones[t];

		// Follow links to get to an actual zone
		while(typeof zoneList == &quot;string&quot;){
			t = zoneList;
			zoneList = _zones[t];
		}
		if(!zoneList){
			// Backward-compat file hasn&#x27;t loaded yet, try looking in there
			if(!_loadedZones.backward){
				// This is for backward entries like &quot;America/Fort_Wayne&quot; that
				// getRegionForTimezone *thinks* it has a region file and zone
				// for (e.g., America =&gt; &#x27;northamerica&#x27;), but in reality it&#x27;s a
				// legacy zone we need the backward file for
				var parsed = loadZoneFile(&quot;backward&quot;, true);
				return getZoneInfo(dt, tz); //Object
			}
			invalidTZError(t);
		}

		if(!_loadedRanges[tz]){
			_loadZoneRanges(tz, zoneList);
		}
		var ranges = _loadedRanges[tz];
		var tm = dt.getTime();
		for(var i = 0, r; (r = ranges[i]); i++){
			if(tm &gt;= r[0] &amp;&amp; tm &lt; r[1]){
				return {zone: zoneList[i], range: ranges[i], idx: i};
			}
		}
		throw new Error(&#x27;No Zone found for &quot;&#x27; + tz + &#x27;&quot; on &#x27; + dt);
	}

	function getRule(/* Date */ dt, /* ZoneInfo */ zoneInfo) {
 		// summary:
		//		Returns the latest-matching rule entry from the zoneinfo
		//		database for the given date and zone

		var lastMatch = -1;
		var rules = zoneInfo.range[2]||[];
		var tsp = dt.getTime();
		var zr = zoneInfo.range;
		for(var i = 0, r; (r = rules[i]); i++){
			if(tsp &gt;= r.d.getTime()){
				lastMatch = i;
			}
		}
		if(lastMatch &gt;= 0){
			return rules[lastMatch].r;
		}
		return null;
	}

	function getAbbreviation(/* String */ tz, /* Object */ zoneInfo, /* Object */ rule) {
		// summary:
		//		Returns the abbreviation for the given zone and rule
		var res;
		var zone = zoneInfo.zone;
		var base = zone[2];
		if(base.indexOf(&#x27;%s&#x27;) &gt; -1){
			var repl;
			if(rule){
				repl = rule[7];
				if(repl == &quot;-&quot;){ repl = &quot;&quot;; }
			}else if(zone[1] in abbrExceptions){
				repl = abbrExceptions[zone[1]];
			}else{
				if(zoneInfo.idx &gt; 0){
					// Check if our previous zone&#x27;s base is the same as our
					// current in &quot;S&quot; (standard) mode.  If so, then use &quot;S&quot;
					// for our replacement
					var pz = _zones[tz][zoneInfo.idx - 1];
					var pb = pz[2];
					if(pb.indexOf(&#x27;%s&#x27;) &lt; 0){
						if(base.replace(&#x27;%s&#x27;, &quot;S&quot;) == pb){
							repl = &quot;S&quot;;
						}else{
							repl = &quot;&quot;;
						}
					}else{
						repl = &quot;&quot;;
					}
				}else{
					repl = &quot;&quot;;
				}
			}
			res = base.replace(&#x27;%s&#x27;, repl);
		}else if(base.indexOf(&quot;/&quot;) &gt; -1){
			var bs = base.split(&quot;/&quot;);
			if(rule){
				res = bs[rule[6] === 0 ? 0 : 1];
			}else{
				res = bs[0];
			}
		}else{
			res = base;
		}
		return res; // String
	}

	lang.setObject(&quot;dojox.date.timezone&quot;, {
		// summary:
		//		mix-in to dojo.date to provide timezones based on
		//		the Olson timezone data
		// description:
		//		mix-in to dojo.date to provide timezones based on
		//		the Olson timezone data.
		//		If you pass &quot;timezone&quot; as a parameter to your format options,
		//		then you get the date formatted (and offset) for that timezone

		getTzInfo: function(/* Date */ dt, /* String */ tz){
			// summary:
			//		Returns the timezone information for the given date and
			//		timezone string
			// dt: Date
			//		The Date - a &quot;proxyDate&quot;
			// tz: String
			//		String representation of the timezone you want to get info
			//		for date

			// Lazy-load any zones not yet loaded
			if(loadingScheme == &quot;lazyLoad&quot;){
				// Get the correct region for the zone
				var zoneFile = getRegionForTimezone(tz);
				if(!zoneFile){
					throw new Error(&quot;Not a valid timezone ID.&quot;);
				}else{
					if(!_loadedZones[zoneFile]){
						// Get the file and parse it -- use synchronous XHR
						loadZoneFile(zoneFile);
					}
				}
			}
			var zoneInfo = getZoneInfo(dt, tz);
			var off = zoneInfo.zone[0];
			// See if the offset needs adjustment
			var rule = getRule(dt, zoneInfo);
			if(rule){
				off += rule[6];
			}else{
				if(_rules[zoneInfo.zone[1]] &amp;&amp; zoneInfo.idx &gt; 0){
					off += getOffsetInMins(_zones[tz][zoneInfo.idx - 1][1]);
				}else{
					off += getOffsetInMins(zoneInfo.zone[1]);
				}
			}

			var abbr = getAbbreviation(tz, zoneInfo, rule);
			return { tzOffset: off, tzAbbr: abbr }; // Object
		},

		loadZoneData: function(data){
			// summary:
			//		Loads the given data object into the zone database
			// data: Object
			//		The data to load - contains &quot;zones&quot; and &quot;rules&quot; parameters
			loadZoneData(data);
		},

		getAllZones: function(){
			// summary:
			//		Returns an array of zones that have been loaded
			var arr = [];
			for(var z in _zones){ arr.push(z); }
			arr.sort();
			return arr; // String[]
		}
	});

	// Now - initialize the stuff that we should have pre-loaded
	if(typeof defaultZoneFile == &quot;string&quot; &amp;&amp; defaultZoneFile){
		defaultZoneFile = [defaultZoneFile];
	}
	if(defaultZoneFile instanceof Array){
		arrayUtil.forEach(defaultZoneFile, loadZoneFile);
	}

	// And enhance the default formatting functions
	// If you pass &quot;timezone&quot; as a parameter to your format options,
	// then you get the date formatted (and offset) for that timezone
	var oLocaleFmt = localeUtil.format,
		oGetZone = localeUtil._getZone;
	localeUtil.format = function(dateObject, options){
		options = options||{};
		if(options.timezone &amp;&amp; !options._tzInfo){
			// Store it in our options so we can use it later
			options._tzInfo = dojox.date.timezone.getTzInfo(dateObject, options.timezone);
		}
		if(options._tzInfo){
			// Roll our date to display the correct time according to the
			// desired offset
			var offset = dateObject.getTimezoneOffset() - options._tzInfo.tzOffset;
			dateObject = new Date(dateObject.getTime() + (offset * 60 * 1000));
		}
		return oLocaleFmt.call(this, dateObject, options);
	};
	localeUtil._getZone = function(dateObject, getName, options){
		if(options._tzInfo){
			return getName ? options._tzInfo.tzAbbr : options._tzInfo.tzOffset;
		}
		return oGetZone.call(this, dateObject, getName, options);
	};

	/*=====
	// Hide these enhancements from the doc parser because they obscure the original definition of _getZone() and
	// format.   TODO: change above overrides to around() advice so that original definitions aren&#x27;t changed.
	 localeUtil.format = oLocaleFmt;
	 localeUtil._getZone = oGetZone;
	=====*/

	return dojox.date.timezone;
});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
